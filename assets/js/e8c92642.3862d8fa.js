"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[966],{33:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"ros2/python-rclpy-bridge","title":"Python rclpy Bridge to Controllers","description":"Learning Objectives","source":"@site/docs/01-ros2/04-python-rclpy-bridge.md","sourceDirName":"01-ros2","slug":"/ros2/python-rclpy-bridge","permalink":"/AI-And-Robotic-Hackathoon/ros2/python-rclpy-bridge","draft":false,"unlisted":false,"editUrl":"https://github.com/mfsrajput/AI-And-Robotic-Hackathoon/edit/main/docs/01-ros2/04-python-rclpy-bridge.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Python rclpy Bridge to Controllers"},"sidebar":"moduleSidebar","previous":{"title":"URDF + Xacro for Humanoids","permalink":"/AI-And-Robotic-Hackathoon/ros2/urdf-xacro-for-humanoids"},"next":{"title":"Gazebo Physics & World Building","permalink":"/AI-And-Robotic-Hackathoon/digital-twin/gazebo-physics-and-world-building"}}');var a=t(4848),o=t(8453);const i={sidebar_position:4,title:"Python rclpy Bridge to Controllers"},s="Python rclpy Bridge to Controllers",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Theory: Python ROS 2 Programming with rclpy",id:"theory-python-ros-2-programming-with-rclpy",level:2},{value:"Node Architecture",id:"node-architecture",level:3},{value:"Asynchronous Programming",id:"asynchronous-programming",level:3},{value:"Threading Considerations",id:"threading-considerations",level:3},{value:"Practice: Implementing Python Controllers",id:"practice-implementing-python-controllers",level:2},{value:"Basic Node Structure",id:"basic-node-structure",level:3},{value:"Creating a Joint Position Controller",id:"creating-a-joint-position-controller",level:3},{value:"Creating a Balance Controller",id:"creating-a-balance-controller",level:3},{value:"Creating a Walking Pattern Generator",id:"creating-a-walking-pattern-generator",level:3},{value:"Active Learning Exercise",id:"active-learning-exercise",level:2},{value:"Worked Example: Black-box to Glass-box - Implementing an Adaptive Walking Controller",id:"worked-example-black-box-to-glass-box---implementing-an-adaptive-walking-controller",level:2},{value:"Black-box View",id:"black-box-view",level:3},{value:"Glass-box Implementation",id:"glass-box-implementation",level:3},{value:"Understanding the Implementation",id:"understanding-the-implementation",level:3},{value:"Tiered Assessments",id:"tiered-assessments",level:2},{value:"Tier 1: Basic Understanding",id:"tier-1-basic-understanding",level:3},{value:"Tier 2: Application",id:"tier-2-application",level:3},{value:"Tier 3: Analysis and Synthesis",id:"tier-3-analysis-and-synthesis",level:3},{value:"Mermaid Diagram",id:"mermaid-diagram",level:2},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2}];function p(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"python-rclpy-bridge-to-controllers",children:"Python rclpy Bridge to Controllers"})}),"\n",(0,a.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(n.p,{children:"By the end of this chapter, students will be able to:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Implement Python nodes using the rclpy library for ROS 2 communication"}),"\n",(0,a.jsx)(n.li,{children:"Create publishers, subscribers, services, and action clients/servers in Python"}),"\n",(0,a.jsx)(n.li,{children:"Interface Python-based controllers with ROS 2 for humanoid robot control"}),"\n",(0,a.jsx)(n.li,{children:"Handle asynchronous operations and callbacks in ROS 2 Python nodes"}),"\n",(0,a.jsx)(n.li,{children:"Design control loops with appropriate timing and synchronization"}),"\n",(0,a.jsx)(n.li,{children:"Implement error handling and safety mechanisms in Python controllers"}),"\n",(0,a.jsx)(n.li,{children:"Integrate Python machine learning models with ROS 2 control systems"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"The Robot Control Library for Python (rclpy) provides Python bindings for ROS 2, enabling developers to create ROS 2 nodes in Python. This is particularly valuable for humanoid robotics, where Python's rich ecosystem of scientific computing, machine learning, and control libraries can be leveraged for complex robot behaviors. The rclpy library allows seamless integration between Python-based algorithms and the ROS 2 ecosystem, making it possible to implement sophisticated controllers for humanoid robots."}),"\n",(0,a.jsx)(n.p,{children:"Python's strengths in rapid prototyping, mathematical computation, and machine learning make it an ideal choice for implementing high-level controllers, motion planners, and perception algorithms for humanoid robots. The rclpy library bridges the gap between Python's capabilities and ROS 2's distributed architecture, allowing developers to create nodes that can communicate with other parts of the robotic system."}),"\n",(0,a.jsx)(n.h2,{id:"theory-python-ros-2-programming-with-rclpy",children:"Theory: Python ROS 2 Programming with rclpy"}),"\n",(0,a.jsx)(n.h3,{id:"node-architecture",children:"Node Architecture"}),"\n",(0,a.jsx)(n.p,{children:"In rclpy, each Python program that participates in the ROS 2 ecosystem is a node. A node can contain:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Publishers: for sending messages to topics"}),"\n",(0,a.jsx)(n.li,{children:"Subscribers: for receiving messages from topics"}),"\n",(0,a.jsx)(n.li,{children:"Service clients: for making requests to services"}),"\n",(0,a.jsx)(n.li,{children:"Service servers: for providing services"}),"\n",(0,a.jsx)(n.li,{children:"Action clients: for sending goals to action servers"}),"\n",(0,a.jsx)(n.li,{children:"Action servers: for executing long-running tasks with feedback"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"asynchronous-programming",children:"Asynchronous Programming"}),"\n",(0,a.jsx)(n.p,{children:"ROS 2 Python nodes typically use asynchronous programming patterns. The rclpy library provides mechanisms for handling callbacks from different communication patterns without blocking the main execution thread. This is crucial for humanoid robot control, where multiple systems need to operate concurrently."}),"\n",(0,a.jsx)(n.h3,{id:"threading-considerations",children:"Threading Considerations"}),"\n",(0,a.jsx)(n.p,{children:"When implementing controllers in Python, it's important to consider the Global Interpreter Lock (GIL) and how it affects real-time performance. While Python may not be suitable for the most time-critical control loops, it excels at higher-level decision making and coordination."}),"\n",(0,a.jsx)(n.h2,{id:"practice-implementing-python-controllers",children:"Practice: Implementing Python Controllers"}),"\n",(0,a.jsx)(n.h3,{id:"basic-node-structure",children:"Basic Node Structure"}),"\n",(0,a.jsx)(n.p,{children:"Let's create a Python package for humanoid controllers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws/src\nros2 pkg create --build-type ament_python humanoid_controllers --dependencies rclpy std_msgs sensor_msgs geometry_msgs control_msgs trajectory_msgs builtin_interfaces\n"})}),"\n",(0,a.jsx)(n.h3,{id:"creating-a-joint-position-controller",children:"Creating a Joint Position Controller"}),"\n",(0,a.jsxs)(n.p,{children:["Create ",(0,a.jsx)(n.code,{children:"~/ros2_ws/src/humanoid_controllers/humanoid_controllers/joint_position_controller.py"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray\nfrom sensor_msgs.msg import JointState\nfrom control_msgs.msg import JointTrajectoryControllerState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nimport numpy as np\nimport time\nfrom builtin_interfaces.msg import Duration\n\nclass JointPositionController(Node):\n    def __init__(self):\n        super().__init__('joint_position_controller')\n\n        # Declare parameters\n        self.declare_parameter('joint_names', ['left_hip_joint', 'left_knee_joint', 'left_ankle_joint'])\n        self.declare_parameter('control_frequency', 50)  # Hz\n        self.declare_parameter('kp', 10.0)  # Proportional gain\n        self.declare_parameter('ki', 0.1)   # Integral gain\n        self.declare_parameter('kd', 0.5)   # Derivative gain\n\n        # Get parameters\n        self.joint_names = self.get_parameter('joint_names').value\n        self.control_frequency = self.get_parameter('control_frequency').value\n        self.kp = self.get_parameter('kp').value\n        self.ki = self.get_parameter('ki').value\n        self.kd = self.get_parameter('kd').value\n\n        # Initialize controller state\n        self.current_positions = {name: 0.0 for name in self.joint_names}\n        self.desired_positions = {name: 0.0 for name in self.joint_names}\n        self.errors = {name: 0.0 for name in self.joint_names}\n        self.integral_errors = {name: 0.0 for name in self.joint_names}\n        self.previous_errors = {name: 0.0 for name in self.joint_names}\n\n        # Create subscribers\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10)\n\n        # Create publishers\n        self.joint_command_pub = self.create_publisher(\n            JointTrajectory,\n            '/joint_trajectory_controller/joint_trajectory',\n            10)\n\n        # Create service server for setting desired positions\n        self.set_position_service = self.create_service(\n            JointTrajectory,\n            'set_joint_positions',\n            self.set_joint_positions_callback)\n\n        # Create timer for control loop\n        self.control_timer = self.create_timer(\n            1.0 / self.control_frequency,\n            self.control_loop)\n\n        self.get_logger().info(f'Joint Position Controller initialized for joints: {self.joint_names}')\n\n    def joint_state_callback(self, msg):\n        \"\"\"Update current joint positions from joint state message\"\"\"\n        for i, name in enumerate(msg.name):\n            if name in self.current_positions:\n                self.current_positions[name] = msg.position[i]\n\n    def set_joint_positions_callback(self, request, response):\n        \"\"\"Service callback to set desired joint positions\"\"\"\n        for point in request.points:\n            for i, joint_name in enumerate(request.joint_names):\n                if joint_name in self.desired_positions:\n                    self.desired_positions[joint_name] = point.positions[i]\n\n        self.get_logger().info(f'Set desired positions: {self.desired_positions}')\n        response.success = True\n        return response\n\n    def control_loop(self):\n        \"\"\"Main control loop implementing PID control\"\"\"\n        # Calculate errors\n        for joint_name in self.joint_names:\n            current_pos = self.current_positions.get(joint_name, 0.0)\n            desired_pos = self.desired_positions.get(joint_name, 0.0)\n\n            error = desired_pos - current_pos\n            self.errors[joint_name] = error\n\n            # Update integral and derivative terms\n            self.integral_errors[joint_name] += error * (1.0 / self.control_frequency)\n            derivative = (error - self.previous_errors[joint_name]) * self.control_frequency\n\n            # PID control law\n            control_output = (self.kp * error +\n                            self.ki * self.integral_errors[joint_name] +\n                            self.kd * derivative)\n\n            self.previous_errors[joint_name] = error\n\n            # Publish control command\n            self.publish_joint_command(joint_name, control_output)\n\n    def publish_joint_command(self, joint_name, control_output):\n        \"\"\"Publish joint trajectory command\"\"\"\n        # Create trajectory message\n        traj_msg = JointTrajectory()\n        traj_msg.joint_names = [joint_name]\n\n        # Create trajectory point\n        point = JointTrajectoryPoint()\n        point.positions = [control_output]  # This would typically be the desired position, not control output\n        point.time_from_start = Duration(sec=0, nanosec=10000000)  # 10ms\n\n        traj_msg.points = [point]\n\n        self.joint_command_pub.publish(traj_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    controller = JointPositionController()\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        controller.get_logger().info('Shutting down Joint Position Controller')\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"creating-a-balance-controller",children:"Creating a Balance Controller"}),"\n",(0,a.jsxs)(n.p,{children:["Create ",(0,a.jsx)(n.code,{children:"~/ros2_ws/src/humanoid_controllers/humanoid_controllers/balance_controller.py"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Imu\nfrom geometry_msgs.msg import Vector3, Point\nfrom std_msgs.msg import Float64\nfrom builtin_interfaces.msg import Duration\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nimport numpy as np\nfrom collections import deque\n\nclass BalanceController(Node):\n    def __init__(self):\n        super().__init__('balance_controller')\n\n        # Declare parameters\n        self.declare_parameter('control_frequency', 100)  # Hz\n        self.declare_parameter('imu_topic', '/imu/data')\n        self.declare_parameter('hip_joint_name', 'left_hip_joint')\n        self.declare_parameter('ankle_joint_name', 'left_ankle_joint')\n        self.declare_parameter('kp_balance', 5.0)\n        self.declare_parameter('ki_balance', 0.1)\n        self.declare_parameter('kd_balance', 1.0)\n\n        # Get parameters\n        self.control_frequency = self.get_parameter('control_frequency').value\n        self.imu_topic = self.get_parameter('imu_topic').value\n        self.hip_joint_name = self.get_parameter('hip_joint_name').value\n        self.ankle_joint_name = self.get_parameter('ankle_joint_name').value\n        self.kp_balance = self.get_parameter('kp_balance').value\n        self.ki_balance = self.get_parameter('ki_balance').value\n        self.kd_balance = self.get_parameter('kd_balance').value\n\n        # Initialize state\n        self.roll = 0.0\n        self.pitch = 0.0\n        self.yaw = 0.0\n        self.roll_velocity = 0.0\n        self.pitch_velocity = 0.0\n        self.yaw_velocity = 0.0\n\n        # PID state for balance\n        self.roll_error = 0.0\n        self.pitch_error = 0.0\n        self.roll_integral = 0.0\n        self.pitch_integral = 0.0\n        self.previous_roll_error = 0.0\n        self.previous_pitch_error = 0.0\n\n        # Create subscribers\n        self.imu_sub = self.create_subscription(\n            Imu,\n            self.imu_topic,\n            self.imu_callback,\n            10)\n\n        # Create publishers\n        self.balance_command_pub = self.create_publisher(\n            JointTrajectory,\n            '/balance_controller/commands',\n            10)\n\n        # Create timer for balance control loop\n        self.balance_timer = self.create_timer(\n            1.0 / self.control_frequency,\n            self.balance_control_loop)\n\n        # Create a history buffer for filtering\n        self.roll_history = deque(maxlen=10)\n        self.pitch_history = deque(maxlen=10)\n\n        self.get_logger().info('Balance Controller initialized')\n\n    def imu_callback(self, msg):\n        \"\"\"Process IMU data to extract orientation and angular velocities\"\"\"\n        # Convert quaternion to Euler angles (roll, pitch, yaw)\n        orientation = msg.orientation\n        self.roll, self.pitch, self.yaw = self.quaternion_to_euler(\n            orientation.w, orientation.x, orientation.y, orientation.z)\n\n        # Get angular velocities\n        self.roll_velocity = msg.angular_velocity.x\n        self.pitch_velocity = msg.angular_velocity.y\n        self.yaw_velocity = msg.angular_velocity.z\n\n        # Add to history for filtering\n        self.roll_history.append(self.roll)\n        self.pitch_history.append(self.pitch)\n\n    def quaternion_to_euler(self, w, x, y, z):\n        \"\"\"Convert quaternion to Euler angles (roll, pitch, yaw)\"\"\"\n        # Roll (x-axis rotation)\n        sinr_cosp = 2 * (w * x + y * z)\n        cosr_cosp = 1 - 2 * (x * x + y * y)\n        roll = np.arctan2(sinr_cosp, cosr_cosp)\n\n        # Pitch (y-axis rotation)\n        sinp = 2 * (w * y - z * x)\n        if np.abs(sinp) >= 1:\n            pitch = np.copysign(np.pi / 2, sinp)  # Use 90 degrees if out of range\n        else:\n            pitch = np.arcsin(sinp)\n\n        # Yaw (z-axis rotation)\n        siny_cosp = 2 * (w * z + x * y)\n        cosy_cosp = 1 - 2 * (y * y + z * z)\n        yaw = np.arctan2(siny_cosp, cosy_cosp)\n\n        return roll, pitch, yaw\n\n    def balance_control_loop(self):\n        \"\"\"Main balance control loop\"\"\"\n        # Calculate desired orientation (typically zero for balance)\n        desired_roll = 0.0\n        desired_pitch = 0.0\n\n        # Calculate errors\n        self.roll_error = desired_roll - self.roll\n        self.pitch_error = desired_pitch - self.pitch\n\n        # Update integral terms\n        self.roll_integral += self.roll_error * (1.0 / self.control_frequency)\n        self.pitch_integral += self.pitch_error * (1.0 / self.control_frequency)\n\n        # Calculate derivatives\n        roll_derivative = (self.roll_error - self.previous_roll_error) * self.control_frequency\n        pitch_derivative = (self.pitch_error - self.previous_pitch_error) * self.control_frequency\n\n        # Update previous errors\n        self.previous_roll_error = self.roll_error\n        self.previous_pitch_error = self.pitch_error\n\n        # Calculate control outputs using PID\n        hip_command = (self.kp_balance * self.roll_error +\n                      self.ki_balance * self.roll_integral +\n                      self.kd_balance * roll_derivative)\n\n        ankle_command = (self.kp_balance * self.pitch_error +\n                        self.ki_balance * self.pitch_integral +\n                        self.kd_balance * pitch_derivative)\n\n        # Publish balance commands\n        self.publish_balance_commands(hip_command, ankle_command)\n\n    def publish_balance_commands(self, hip_command, ankle_command):\n        \"\"\"Publish balance control commands as joint trajectory\"\"\"\n        traj_msg = JointTrajectory()\n        traj_msg.joint_names = [self.hip_joint_name, self.ankle_joint_name]\n\n        point = JointTrajectoryPoint()\n        point.positions = [hip_command, ankle_command]\n        point.velocities = [0.0, 0.0]  # Zero velocity for now\n        point.time_from_start = Duration(sec=0, nanosec=10000000)  # 10ms\n\n        traj_msg.points = [point]\n\n        self.balance_command_pub.publish(traj_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    controller = BalanceController()\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        controller.get_logger().info('Shutting down Balance Controller')\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"creating-a-walking-pattern-generator",children:"Creating a Walking Pattern Generator"}),"\n",(0,a.jsxs)(n.p,{children:["Create ",(0,a.jsx)(n.code,{children:"~/ros2_ws/src/humanoid_controllers/humanoid_controllers/walking_pattern_generator.py"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray\nfrom geometry_msgs.msg import Twist\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom builtin_interfaces.msg import Duration\nimport numpy as np\nimport math\n\nclass WalkingPatternGenerator(Node):\n    def __init__(self):\n        super().__init__('walking_pattern_generator')\n\n        # Declare parameters\n        self.declare_parameter('control_frequency', 50)  # Hz\n        self.declare_parameter('step_height', 0.05)     # meters\n        self.declare_parameter('step_length', 0.3)      # meters\n        self.declare_parameter('step_duration', 1.0)    # seconds\n        self.declare_parameter('hip_joint_name', 'left_hip_joint')\n        self.declare_parameter('knee_joint_name', 'left_knee_joint')\n        self.declare_parameter('ankle_joint_name', 'left_ankle_joint')\n\n        # Get parameters\n        self.control_frequency = self.get_parameter('control_frequency').value\n        self.step_height = self.get_parameter('step_height').value\n        self.step_length = self.get_parameter('step_length').value\n        self.step_duration = self.get_parameter('step_duration').value\n        self.hip_joint_name = self.get_parameter('hip_joint_name').value\n        self.knee_joint_name = self.get_parameter('knee_joint_name').value\n        self.ankle_joint_name = self.get_parameter('ankle_joint_name').value\n\n        # Initialize walking state\n        self.walk_enabled = False\n        self.walk_speed = 0.0\n        self.walk_direction = 0.0  # radians\n        self.walk_phase = 0.0      # 0 to 2*pi\n        self.step_count = 0\n\n        # Create subscribers\n        self.cmd_vel_sub = self.create_subscription(\n            Twist,\n            'cmd_vel',\n            self.cmd_vel_callback,\n            10)\n\n        # Create publishers\n        self.trajectory_pub = self.create_publisher(\n            JointTrajectory,\n            '/walking_controller/trajectory',\n            10)\n\n        # Create timer for walking pattern generation\n        self.walk_timer = self.create_timer(\n            1.0 / self.control_frequency,\n            self.walk_pattern_generator)\n\n        self.get_logger().info('Walking Pattern Generator initialized')\n\n    def cmd_vel_callback(self, msg):\n        \"\"\"Handle velocity commands\"\"\"\n        self.walk_speed = math.sqrt(msg.linear.x**2 + msg.linear.y**2)\n        self.walk_direction = math.atan2(msg.linear.y, msg.linear.x)\n\n        # Enable walking if speed is above threshold\n        self.walk_enabled = self.walk_speed > 0.01  # 1cm/s threshold\n\n        if self.walk_enabled:\n            self.get_logger().info(f'Walking: speed={self.walk_speed:.2f} m/s, direction={math.degrees(self.walk_direction):.1f}\xb0')\n\n    def walk_pattern_generator(self):\n        \"\"\"Generate walking pattern based on desired velocity\"\"\"\n        if not self.walk_enabled:\n            # Publish zero commands when not walking\n            self.publish_zero_commands()\n            return\n\n        # Update walking phase\n        self.walk_phase += 2 * math.pi * (1.0 / self.control_frequency) / self.step_duration\n\n        if self.walk_phase >= 2 * math.pi:\n            self.walk_phase = 0.0\n            self.step_count += 1\n\n        # Calculate joint positions based on walking phase\n        hip_pos, knee_pos, ankle_pos = self.calculate_leg_trajectory(self.walk_phase)\n\n        # Publish trajectory\n        self.publish_trajectory(hip_pos, knee_pos, ankle_pos)\n\n    def calculate_leg_trajectory(self, phase):\n        \"\"\"Calculate leg joint positions based on walking phase\"\"\"\n        # Simplified walking pattern using sinusoidal functions\n        # Phase: 0 to pi (swing phase), pi to 2*pi (stance phase)\n\n        if phase < math.pi:\n            # Swing phase - leg moves forward\n            swing_progress = phase / math.pi\n\n            # Hip moves to lift leg and move forward\n            hip_pos = -0.1 + 0.05 * math.sin(phase)  # Oscillate around -0.1\n\n            # Knee bends to clear ground\n            knee_pos = -0.5 + 0.3 * math.sin(phase)  # Bend more during swing\n\n            # Ankle adjusts for foot placement\n            ankle_pos = 0.2 + 0.1 * math.sin(phase)  # Oscillate around 0.2\n        else:\n            # Stance phase - leg supports body\n            stance_phase = phase - math.pi\n            stance_progress = stance_phase / math.pi\n\n            # Hip maintains support\n            hip_pos = -0.05 + 0.02 * math.sin(stance_phase * 2)  # Small oscillation\n\n            # Knee extends for support\n            knee_pos = -0.2 - 0.2 * math.sin(stance_phase)  # Extend during stance\n\n            # Ankle maintains contact\n            ankle_pos = 0.1 + 0.05 * math.sin(stance_phase * 2)  # Small adjustment\n\n        return hip_pos, knee_pos, ankle_pos\n\n    def publish_trajectory(self, hip_pos, knee_pos, ankle_pos):\n        \"\"\"Publish joint trajectory for walking\"\"\"\n        traj_msg = JointTrajectory()\n        traj_msg.joint_names = [self.hip_joint_name, self.knee_joint_name, self.ankle_joint_name]\n\n        point = JointTrajectoryPoint()\n        point.positions = [hip_pos, knee_pos, ankle_pos]\n        point.velocities = [0.0, 0.0, 0.0]  # Would be calculated in a real implementation\n        point.time_from_start = Duration(sec=0, nanosec=int(1000000000.0 / self.control_frequency))\n\n        traj_msg.points = [point]\n\n        self.trajectory_pub.publish(traj_msg)\n\n    def publish_zero_commands(self):\n        \"\"\"Publish zero joint positions when not walking\"\"\"\n        traj_msg = JointTrajectory()\n        traj_msg.joint_names = [self.hip_joint_name, self.knee_joint_name, self.ankle_joint_name]\n\n        point = JointTrajectoryPoint()\n        point.positions = [0.0, 0.0, 0.0]\n        point.velocities = [0.0, 0.0, 0.0]\n        point.time_from_start = Duration(sec=0, nanosec=10000000)\n\n        traj_msg.points = [point]\n\n        self.trajectory_pub.publish(traj_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    generator = WalkingPatternGenerator()\n\n    try:\n        rclpy.spin(generator)\n    except KeyboardInterrupt:\n        generator.get_logger().info('Shutting down Walking Pattern Generator')\n    finally:\n        generator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"active-learning-exercise",children:"Active Learning Exercise"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Exercise: Implementing a Python-based Vision Controller"})}),"\n",(0,a.jsx)(n.p,{children:"Using the patterns demonstrated in the examples above, implement a Python controller that:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Subscribes to a camera topic (sensor_msgs/Image)"}),"\n",(0,a.jsx)(n.li,{children:"Processes the image to detect an object (you can simulate this with a simple condition)"}),"\n",(0,a.jsx)(n.li,{children:"Calculates the necessary joint movements to point the robot's head at the object"}),"\n",(0,a.jsx)(n.li,{children:"Publishes joint trajectory commands to move the head"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Consider the timing constraints for real-time image processing and how to maintain a consistent control loop frequency. Discuss potential challenges with this approach and possible solutions."}),"\n",(0,a.jsx)(n.h2,{id:"worked-example-black-box-to-glass-box---implementing-an-adaptive-walking-controller",children:"Worked Example: Black-box to Glass-box - Implementing an Adaptive Walking Controller"}),"\n",(0,a.jsx)(n.h3,{id:"black-box-view",children:"Black-box View"}),"\n",(0,a.jsx)(n.p,{children:"We'll implement an adaptive walking controller that adjusts its gait based on terrain feedback. The black-box view is: the controller receives sensor data about the terrain, adjusts walking parameters accordingly, and produces stable walking patterns adapted to the current conditions."}),"\n",(0,a.jsx)(n.h3,{id:"glass-box-implementation",children:"Glass-box Implementation"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Create the adaptive walking controller:"})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Create ",(0,a.jsx)(n.code,{children:"~/ros2_ws/src/humanoid_controllers/humanoid_controllers/adaptive_walking_controller.py"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu, LaserScan\nfrom geometry_msgs.msg import Twist\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom std_msgs.msg import Float64\nfrom builtin_interfaces.msg import Duration\nimport numpy as np\nimport math\nfrom collections import deque\n\nclass AdaptiveWalkingController(Node):\n    def __init__(self):\n        super().__init__('adaptive_walking_controller')\n\n        # Declare parameters\n        self.declare_parameter('control_frequency', 100)  # Hz\n        self.declare_parameter('base_step_height', 0.05)  # meters\n        self.declare_parameter('base_step_length', 0.3)   # meters\n        self.declare_parameter('base_step_duration', 1.0) # seconds\n        self.declare_parameter('max_adaptation_factor', 1.5)  # maximum adaptation multiplier\n        self.declare_parameter('min_adaptation_factor', 0.7)  # minimum adaptation multiplier\n\n        # Get parameters\n        self.control_frequency = self.get_parameter('control_frequency').value\n        self.base_step_height = self.get_parameter('base_step_height').value\n        self.base_step_length = self.get_parameter('base_step_length').value\n        self.base_step_duration = self.get_parameter('base_step_duration').value\n        self.max_adaptation = self.get_parameter('max_adaptation_factor').value\n        self.min_adaptation = self.get_parameter('min_adaptation_factor').value\n\n        # Initialize state\n        self.walk_enabled = False\n        self.walk_speed = 0.0\n        self.walk_direction = 0.0\n        self.walk_phase = 0.0\n        self.step_count = 0\n\n        # Terrain adaptation state\n        self.terrain_roughness = 0.0\n        self.foot_pressure_left = 0.0\n        self.foot_pressure_right = 0.0\n        self.balance_error = 0.0\n\n        # Adaptation factors (start with base values)\n        self.height_factor = 1.0\n        self.length_factor = 1.0\n        self.duration_factor = 1.0\n\n        # Create subscribers\n        self.cmd_vel_sub = self.create_subscription(\n            Twist,\n            'cmd_vel',\n            self.cmd_vel_callback,\n            10)\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            '/imu/data',\n            self.imu_callback,\n            10)\n\n        self.laser_sub = self.create_subscription(\n            LaserScan,\n            '/scan',\n            self.laser_callback,\n            10)\n\n        # Create publishers\n        self.trajectory_pub = self.create_publisher(\n            JointTrajectory,\n            '/adaptive_walking_controller/trajectory',\n            10)\n\n        self.adaptation_pub = self.create_publisher(\n            Float64,\n            '/adaptation_factor',\n            10)\n\n        # Create timer for control loop\n        self.control_timer = self.create_timer(\n            1.0 / self.control_frequency,\n            self.control_loop)\n\n        # Create history buffers for terrain analysis\n        self.terrain_history = deque(maxlen=50)\n        self.balance_history = deque(maxlen=50)\n\n        self.get_logger().info('Adaptive Walking Controller initialized')\n\n    def cmd_vel_callback(self, msg):\n        \"\"\"Handle velocity commands\"\"\"\n        self.walk_speed = math.sqrt(msg.linear.x**2 + msg.linear.y**2)\n        self.walk_direction = math.atan2(msg.linear.y, msg.linear.x)\n        self.walk_enabled = self.walk_speed > 0.01  # 1cm/s threshold\n\n    def imu_callback(self, msg):\n        \"\"\"Process IMU data for balance feedback\"\"\"\n        # Calculate balance error from roll and pitch\n        roll, pitch, _ = self.quaternion_to_euler(\n            msg.orientation.w, msg.orientation.x,\n            msg.orientation.y, msg.orientation.z)\n\n        # Balance error is a combination of roll and pitch angles\n        self.balance_error = abs(roll) + abs(pitch)\n\n        # Add to history for analysis\n        self.balance_history.append(self.balance_error)\n\n    def laser_callback(self, msg):\n        \"\"\"Process laser scan for terrain analysis\"\"\"\n        # Analyze terrain roughness from laser scan\n        # This is a simplified approach - in reality, you'd use more sophisticated methods\n        if len(msg.ranges) > 0:\n            # Calculate variance in distances as a measure of terrain roughness\n            valid_ranges = [r for r in msg.ranges if msg.range_min < r < msg.range_max]\n            if len(valid_ranges) > 10:  # Need enough samples\n                mean_range = sum(valid_ranges) / len(valid_ranges)\n                variance = sum((r - mean_range)**2 for r in valid_ranges) / len(valid_ranges)\n                self.terrain_roughness = min(variance, 1.0)  # Cap the value\n\n        # Add to history\n        self.terrain_history.append(self.terrain_roughness)\n\n    def quaternion_to_euler(self, w, x, y, z):\n        \"\"\"Convert quaternion to Euler angles (roll, pitch, yaw)\"\"\"\n        # Roll (x-axis rotation)\n        sinr_cosp = 2 * (w * x + y * z)\n        cosr_cosp = 1 - 2 * (x * x + y * y)\n        roll = np.arctan2(sinr_cosp, cosr_cosp)\n\n        # Pitch (y-axis rotation)\n        sinp = 2 * (w * y - z * x)\n        if np.abs(sinp) >= 1:\n            pitch = np.copysign(np.pi / 2, sinp)\n        else:\n            pitch = np.arcsin(sinp)\n\n        # Yaw (z-axis rotation)\n        siny_cosp = 2 * (w * z + x * y)\n        cosy_cosp = 1 - 2 * (y * y + z * z)\n        yaw = np.arctan2(siny_cosp, cosy_cosp)\n\n        return roll, pitch, yaw\n\n    def calculate_adaptation_factors(self):\n        \"\"\"Calculate adaptation factors based on sensor feedback\"\"\"\n        # Terrain-based adaptations\n        terrain_factor = 1.0 + (self.terrain_roughness * 0.3)  # Increase step height on rough terrain\n\n        # Balance-based adaptations\n        balance_factor = 1.0 + (self.balance_error * 0.5)  # Be more careful when off-balance\n\n        # Combine factors with limits\n        self.height_factor = max(self.min_adaptation,\n                                min(self.max_adaptation, terrain_factor))\n        self.length_factor = max(self.min_adaptation * 0.8,\n                                min(self.max_adaptation * 0.8, 1.0 / balance_factor))\n        self.duration_factor = max(self.min_adaptation * 1.2,\n                                  min(self.max_adaptation * 1.2, balance_factor))\n\n    def control_loop(self):\n        \"\"\"Main control loop\"\"\"\n        # Update adaptation factors based on sensor feedback\n        self.calculate_adaptation_factors()\n\n        # Publish adaptation factors for monitoring\n        adapt_msg = Float64()\n        adapt_msg.data = (self.height_factor + self.length_factor + self.duration_factor) / 3.0\n        self.adaptation_pub.publish(adapt_msg)\n\n        if not self.walk_enabled:\n            # Publish zero commands when not walking\n            self.publish_zero_commands()\n            return\n\n        # Update walking phase with adaptation\n        adapted_duration = self.base_step_duration * self.duration_factor\n        phase_increment = 2 * math.pi * (1.0 / self.control_frequency) / adapted_duration\n\n        self.walk_phase += phase_increment\n\n        if self.walk_phase >= 2 * math.pi:\n            self.walk_phase = 0.0\n            self.step_count += 1\n\n        # Calculate adapted walking parameters\n        adapted_height = self.base_step_height * self.height_factor\n        adapted_length = self.base_step_length * self.length_factor\n\n        # Calculate joint positions based on adapted parameters\n        hip_pos, knee_pos, ankle_pos = self.calculate_adapted_leg_trajectory(\n            self.walk_phase, adapted_height, adapted_length)\n\n        # Publish trajectory\n        self.publish_trajectory(hip_pos, knee_pos, ankle_pos)\n\n    def calculate_adapted_leg_trajectory(self, phase, height, length):\n        \"\"\"Calculate leg trajectory with adapted parameters\"\"\"\n        # Adjust trajectory based on adapted parameters\n        if phase < math.pi:\n            # Swing phase - adapted for terrain\n            swing_progress = phase / math.pi\n\n            # Hip moves with adapted height and length\n            hip_pos = -0.1 + (height * 0.5) * math.sin(phase)\n\n            # Knee bends more on rough terrain\n            knee_bend_factor = 0.3 + (self.terrain_roughness * 0.2)\n            knee_pos = -0.5 + knee_bend_factor * math.sin(phase)\n\n            # Ankle adjusts for terrain\n            ankle_pos = 0.2 + (height * 0.2) * math.sin(phase)\n        else:\n            # Stance phase - adapted for stability\n            stance_phase = phase - math.pi\n            stance_progress = stance_phase / math.pi\n\n            # Hip maintains adapted support\n            hip_pos = -0.05 + (height * 0.1) * math.sin(stance_phase * 2)\n\n            # Knee extends for support\n            knee_pos = -0.2 - (length * 0.2) * math.sin(stance_phase)\n\n            # Ankle maintains contact\n            ankle_pos = 0.1 + (height * 0.05) * math.sin(stance_phase * 2)\n\n        return hip_pos, knee_pos, ankle_pos\n\n    def publish_trajectory(self, hip_pos, knee_pos, ankle_pos):\n        \"\"\"Publish joint trajectory for adaptive walking\"\"\"\n        traj_msg = JointTrajectory()\n        traj_msg.joint_names = ['left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n                               'right_hip_joint', 'right_knee_joint', 'right_ankle_joint']\n\n        point = JointTrajectoryPoint()\n        # For simplicity, use same values for both legs (in a real system, they'd be different)\n        point.positions = [hip_pos, knee_pos, ankle_pos, hip_pos, knee_pos, ankle_pos]\n        point.velocities = [0.0] * 6  # Would be calculated in a real implementation\n        point.time_from_start = Duration(\n            sec=0,\n            nanosec=int(1000000000.0 / self.control_frequency))\n\n        traj_msg.points = [point]\n\n        self.trajectory_pub.publish(traj_msg)\n\n    def publish_zero_commands(self):\n        \"\"\"Publish zero joint positions when not walking\"\"\"\n        traj_msg = JointTrajectory()\n        traj_msg.joint_names = ['left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n                               'right_hip_joint', 'right_knee_joint', 'right_ankle_joint']\n\n        point = JointTrajectoryPoint()\n        point.positions = [0.0] * 6\n        point.velocities = [0.0] * 6\n        point.time_from_start = Duration(sec=0, nanosec=10000000)\n\n        traj_msg.points = [point]\n\n        self.trajectory_pub.publish(traj_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    controller = AdaptiveWalkingController()\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        controller.get_logger().info('Shutting down Adaptive Walking Controller')\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Update the package setup.py:"})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Edit ",(0,a.jsx)(n.code,{children:"~/ros2_ws/src/humanoid_controllers/setup.py"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from setuptools import find_packages, setup\nimport os\nfrom glob import glob\n\npackage_name = 'humanoid_controllers'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=find_packages(exclude=['test']),\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n        # Include launch files\n        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='your_name',\n    maintainer_email='your_email@example.com',\n    description='Python controllers for humanoid robots',\n    license='Apache-2.0',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'joint_position_controller = humanoid_controllers.joint_position_controller:main',\n            'balance_controller = humanoid_controllers.balance_controller:main',\n            'walking_pattern_generator = humanoid_controllers.walking_pattern_generator:main',\n            'adaptive_walking_controller = humanoid_controllers.adaptive_walking_controller:main',\n        ],\n    },\n)\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"3",children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Build the package:"})}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select humanoid_controllers\nsource install/setup.bash\n"})}),"\n",(0,a.jsx)(n.h3,{id:"understanding-the-implementation",children:"Understanding the Implementation"}),"\n",(0,a.jsx)(n.p,{children:"The glass-box view reveals:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The controller uses multiple sensor inputs (IMU, laser, velocity commands) to adapt its behavior"}),"\n",(0,a.jsx)(n.li,{children:"The adaptation algorithm adjusts walking parameters based on terrain roughness and balance state"}),"\n",(0,a.jsx)(n.li,{children:"The control loop maintains timing constraints while processing sensor data"}),"\n",(0,a.jsx)(n.li,{children:"The implementation includes safety limits to prevent extreme adaptations"}),"\n",(0,a.jsx)(n.li,{children:"The system publishes monitoring data to track adaptation factors"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"tiered-assessments",children:"Tiered Assessments"}),"\n",(0,a.jsx)(n.h3,{id:"tier-1-basic-understanding",children:"Tier 1: Basic Understanding"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"What is rclpy and what is its role in ROS 2?"}),"\n",(0,a.jsx)(n.li,{children:"Name the main types of communication patterns available in rclpy."}),"\n",(0,a.jsx)(n.li,{children:"What is the purpose of the control loop timer in a Python controller?"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"tier-2-application",children:"Tier 2: Application"}),"\n",(0,a.jsxs)(n.ol,{start:"4",children:["\n",(0,a.jsx)(n.li,{children:"Create a Python node that subscribes to IMU data and publishes joint commands to maintain balance."}),"\n",(0,a.jsx)(n.li,{children:"Implement a simple PID controller in Python for joint position control."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"tier-3-analysis-and-synthesis",children:"Tier 3: Analysis and Synthesis"}),"\n",(0,a.jsxs)(n.ol,{start:"6",children:["\n",(0,a.jsx)(n.li,{children:"Design a complete control architecture for a humanoid robot using multiple Python controllers, considering real-time constraints, safety requirements, and coordination between different control systems."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"mermaid-diagram",children:"Mermaid Diagram"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:'graph TB\n    subgraph "Python Controllers"\n        A[Joint Position Controller]\n        B[Balance Controller]\n        C[Walking Pattern Generator]\n        D[Adaptive Walking Controller]\n    end\n\n    subgraph "ROS 2 System"\n        E[Joint State Publisher]\n        F[IMU Sensor]\n        G[Laser Scanner]\n        H[Command Velocity]\n    end\n\n    subgraph "Hardware Interface"\n        I[Joint Trajectory Controller]\n        J[Robot Hardware]\n    end\n\n    E --\x3e A\n    F --\x3e B\n    G --\x3e D\n    H --\x3e C\n    A --\x3e I\n    B --\x3e I\n    C --\x3e I\n    D --\x3e I\n    I --\x3e J\n\n    style A fill:#ff9999\n    style B fill:#ff9999\n    style C fill:#ff9999\n    style D fill:#ff9999\n    style I fill:#99ccff\n    style J fill:#99ff99\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Alt-text for diagram:"}),' "System architecture diagram showing Python controllers (Joint Position, Balance, Walking Pattern Generator, and Adaptive Walking) interfacing with ROS 2 system components (Joint State Publisher, IMU Sensor, Laser Scanner, Command Velocity) and hardware interface (Joint Trajectory Controller and Robot Hardware). The controllers are highlighted in pink, the hardware interface in blue and green respectively."']}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"This chapter covered the implementation of Python-based controllers for humanoid robots using the rclpy library. We explored how to create nodes that interface with the ROS 2 ecosystem, handle different communication patterns, and implement control algorithms for joint positioning, balance, and walking. The examples demonstrated practical implementations of controllers that can adapt to changing conditions and sensor feedback, which is essential for humanoid robot operation in real-world environments."}),"\n",(0,a.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Quigley, M., Gerkey, B., & Smart, W. D. (2019). Programming robots with ROS: a practical introduction to the Robot Operating System. O'Reilly Media."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Bou-Ammar, H., Ralaivola, L., & Duffner, S. (2019). Practical robotics software development in C++. Apress."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Siciliano, B., & Khatib, O. (2016). Springer handbook of robotics. Springer Publishing Company, Incorporated."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Lentin, J. (2018). Mastering ROS for robotics programming. Packt Publishing."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Tedrake, R. (2019). Underactuated robotics: Algorithms for walking, running, swimming, flying, and manipulation. MIT Press."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Khatib, O., Park, H. W., Verrelst, B., Kim, B. S., Dalloul, I., & Yokoi, K. (2016). Humanoid robot control system framework for supporting different programming methods. ",(0,a.jsx)(n.em,{children:"2016 IEEE-RAS 16th International Conference on Humanoid Robots (Humanoids)"}),", 83-88."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Ha, I., Tamura, Y., Asama, H., &\u767d\u4e91, J. (2015). Real-time walking pattern generation based on control of the zero-moment point for a full-size humanoid robot. ",(0,a.jsx)(n.em,{children:"Advanced Robotics"}),", 29(1), 1-14."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Nakanishi, J., Cory, R., Mistry, M., Peters, J., & Schaal, S. (2008). Operational space control: A theoretical and empirical comparison. ",(0,a.jsx)(n.em,{children:"International Journal of Robotics Research"}),", 27(6), 737-757."]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var r=t(6540);const a={},o=r.createContext(a);function i(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);