"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[314],{8453:(n,e,a)=>{a.d(e,{R:()=>s,x:()=>r});var o=a(6540);const t={},i=o.createContext(t);function s(n){const e=o.useContext(i);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),o.createElement(i.Provider,{value:e},n.children)}},9460:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>_});const o=JSON.parse('{"id":"nvidia-isaac/nav2-bipedal-locomotion","title":"Nav2 for Bipedal Humanoids","description":"Learning Objectives","source":"@site/docs/03-nvidia-isaac/03-nav2-bipedal-locomotion.md","sourceDirName":"03-nvidia-isaac","slug":"/nvidia-isaac/nav2-bipedal-locomotion","permalink":"/nvidia-isaac/nav2-bipedal-locomotion","draft":false,"unlisted":false,"editUrl":"https://github.com/mfsrajput/AI-And-Robotic-Hackathoon/edit/main/docs/03-nvidia-isaac/03-nav2-bipedal-locomotion.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Nav2 for Bipedal Humanoids"},"sidebar":"moduleSidebar","previous":{"title":"Isaac ROS + Hardware-Accelerated VSLAM","permalink":"/nvidia-isaac/isaac-ros-vslam-perception"},"next":{"title":"Sim-to-Real Transfer Techniques","permalink":"/nvidia-isaac/sim-to-real-transfer"}}');var t=a(4848),i=a(8453);const s={sidebar_position:3,title:"Nav2 for Bipedal Humanoids"},r="Nav2 for Bipedal Humanoids",l={},_=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Theory: Bipedal Navigation Fundamentals",id:"theory-bipedal-navigation-fundamentals",level:2},{value:"Dynamic Stability in Bipedal Navigation",id:"dynamic-stability-in-bipedal-navigation",level:3},{value:"Locomotion Patterns",id:"locomotion-patterns",level:3},{value:"Terrain Classification for Humanoids",id:"terrain-classification-for-humanoids",level:3},{value:"Practice: Nav2 Customization for Humanoid Robots",id:"practice-nav2-customization-for-humanoid-robots",level:2},{value:"Custom Nav2 Configuration for Humanoids",id:"custom-nav2-configuration-for-humanoids",level:3},{value:"Humanoid Footstep Planner Implementation",id:"humanoid-footstep-planner-implementation",level:3},{value:"Humanoid Controller Implementation",id:"humanoid-controller-implementation",level:3},{value:"Nav2 Behavior Tree for Humanoid Navigation",id:"nav2-behavior-tree-for-humanoid-navigation",level:3},{value:"Active Learning Exercise",id:"active-learning-exercise",level:2},{value:"Worked Example: Black-box to Glass-box - Humanoid Navigation System",id:"worked-example-black-box-to-glass-box---humanoid-navigation-system",level:2},{value:"Black-box View",id:"black-box-view",level:3},{value:"Glass-box Implementation",id:"glass-box-implementation",level:3},{value:"Understanding the Implementation",id:"understanding-the-implementation",level:3},{value:"Tiered Assessments",id:"tiered-assessments",level:2},{value:"Tier 1: Basic Understanding",id:"tier-1-basic-understanding",level:3},{value:"Tier 2: Application",id:"tier-2-application",level:3},{value:"Tier 3: Analysis and Synthesis",id:"tier-3-analysis-and-synthesis",level:3},{value:"Mermaid Diagram",id:"mermaid-diagram",level:2},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"nav2-for-bipedal-humanoids",children:"Nav2 for Bipedal Humanoids"})}),"\n",(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this chapter, students will be able to:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Configure and customize Nav2 for bipedal humanoid robot navigation"}),"\n",(0,t.jsx)(e.li,{children:"Implement specialized planners for legged robot locomotion"}),"\n",(0,t.jsx)(e.li,{children:"Integrate balance and stability constraints into navigation planning"}),"\n",(0,t.jsx)(e.li,{children:"Design terrain-aware navigation systems for humanoid robots"}),"\n",(0,t.jsx)(e.li,{children:"Implement gait-based path following for bipedal locomotion"}),"\n",(0,t.jsx)(e.li,{children:"Handle dynamic obstacle avoidance for humanoid navigation"}),"\n",(0,t.jsx)(e.li,{children:"Validate navigation performance in complex humanoid scenarios"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(e.p,{children:"Navigation for bipedal humanoid robots presents unique challenges that differ significantly from wheeled or tracked robot navigation. While Nav2 provides a robust framework for mobile robot navigation, humanoid robots require specialized considerations for balance, stability, and locomotion patterns. Unlike wheeled robots that can move in any direction with simple differential drive, humanoid robots must maintain balance while navigating, follow specific footstep patterns, and adapt their gait to terrain conditions."}),"\n",(0,t.jsx)(e.p,{children:"The Nav2 framework provides a flexible, behavior-tree-based architecture that can be extended and customized for humanoid robot navigation. However, the standard 2D navigation stack must be augmented with additional components to handle the unique requirements of bipedal locomotion, including footstep planning, balance control, and gait adaptation."}),"\n",(0,t.jsx)(e.p,{children:"Humanoid navigation must account for the robot's dynamic stability, which is inherently less stable than wheeled platforms. The navigation system must ensure that planned paths are not only collision-free but also dynamically feasible for the robot's bipedal locomotion system. This requires integration with the robot's balance control system and gait generation algorithms."}),"\n",(0,t.jsx)(e.h2,{id:"theory-bipedal-navigation-fundamentals",children:"Theory: Bipedal Navigation Fundamentals"}),"\n",(0,t.jsx)(e.h3,{id:"dynamic-stability-in-bipedal-navigation",children:"Dynamic Stability in Bipedal Navigation"}),"\n",(0,t.jsx)(e.p,{children:"Bipedal robots must maintain dynamic stability during locomotion, which requires careful consideration of:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),": The point where the sum of all moments caused by external forces equals zero"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Capture Point"}),": The location where the robot must step to come to a complete stop"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Center of Mass (CoM) Control"}),": Managing the robot's CoM trajectory to maintain balance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Footstep Planning"}),": Determining where and when to place feet to maintain stability"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"locomotion-patterns",children:"Locomotion Patterns"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots typically use several locomotion patterns:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Static Walking"}),": Maintaining static stability at each step"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Walking"}),": Using dynamic balance with continuous movement"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Running"}),": Brief flight phases between steps"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Climbing"}),": Specialized gait for traversing stairs or obstacles"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"terrain-classification-for-humanoids",children:"Terrain Classification for Humanoids"}),"\n",(0,t.jsx)(e.p,{children:"Navigation for bipedal robots requires understanding terrain characteristics:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Walkable Surfaces"}),": Flat ground, ramps, stairs"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Obstacle Traversal"}),": Steps, curbs, small obstacles"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Terrain Roughness"}),": Effects on stability and gait selection"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Surface Compliance"}),": Soft surfaces that affect foot placement"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"practice-nav2-customization-for-humanoid-robots",children:"Practice: Nav2 Customization for Humanoid Robots"}),"\n",(0,t.jsx)(e.h3,{id:"custom-nav2-configuration-for-humanoids",children:"Custom Nav2 Configuration for Humanoids"}),"\n",(0,t.jsxs)(e.p,{children:["Create ",(0,t.jsx)(e.code,{children:"~/ros2_ws/src/humanoid_nav2/config/humanoid_nav2_params.yaml"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# Nav2 Configuration for Bipedal Humanoid Robot\n\nbt_navigator:\n  ros__parameters:\n    use_sim_time: False\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    # Specify the path where the behavior tree XML files are located\n    default_nav_through_poses_bt_xml: humanoid_navigate_through_poses_w_replanning_and_recovery.xml\n    default_nav_to_pose_bt_xml: humanoid_navigate_to_pose_w_replanning_and_recovery.xml\n    # Recovery nodes\n    node_sequence_with_recovery:\n      plugin: "nav2_bt_navigator/NodeSequenceWithRecovery"\n    round_robin:\n      plugin: "nav2_bt_navigator/RoundRobin"\n    recovery_node:\n      plugin: "nav2_bt_navigator/RecoveryNode"\n    pipeline_sequence:\n      plugin: "nav2_bt_navigator/PipelineSequence"\n    round_robin_with_fallback:\n      plugin: "nav2_bt_navigator/RoundRobinWithFallback"\n\nbt_navigator_navigate_through_poses_rclcpp_node:\n  ros__parameters:\n    use_sim_time: False\n\nbt_navigator_navigate_to_pose_rclcpp_node:\n  ros__parameters:\n    use_sim_time: False\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: False\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.5\n    min_theta_velocity_threshold: 0.001\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["HumanoidController"]\n\n    # Humanoid Controller specific parameters\n    HumanoidController:\n      plugin: "humanoid_nav2_controllers::HumanoidFootstepController"\n      max_translational_vel: 0.3  # Slower for stability\n      max_rotational_vel: 0.3\n      min_translational_vel: 0.05\n      min_rotational_vel: 0.1\n      translational_acc_lim: 0.2\n      rotational_acc_lim: 0.3\n      xy_goal_tolerance: 0.2  # Larger for humanoid precision\n      yaw_goal_tolerance: 0.2\n      stateful: True\n      # Humanoid-specific parameters\n      step_size: 0.3          # Maximum step length\n      step_duration: 1.0      # Time per step\n      balance_margin: 0.1     # Safety margin for balance\n      foot_separation: 0.2    # Distance between feet\n\nprogress_checker:\n  ros__parameters:\n    use_sim_time: False\n    plugin: "nav2_controller::SimpleProgressChecker"\n    required_movement_radius: 0.5  # Humanoid-specific\n    movement_time_allowance: 10.0\n\ngoal_checker:\n  ros__parameters:\n    use_sim_time: False\n    plugin: "nav2_controller::SimpleGoalChecker"\n    xy_goal_tolerance: 0.3    # Larger for humanoid\n    yaw_goal_tolerance: 0.3\n    stateful: True\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 10.0\n      publish_frequency: 5.0\n      global_frame: odom\n      robot_base_frame: base_link\n      use_sim_time: False\n      rolling_window: true\n      width: 6\n      height: 6\n      resolution: 0.05  # Higher resolution for precise foot placement\n      robot_radius: 0.3 # Larger for humanoid safety\n      plugins: ["voxel_layer", "inflation_layer"]\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0  # Higher for humanoid safety\n        inflation_radius: 0.5\n      voxel_layer:\n        plugin: "nav2_costmap_2d::VoxelLayer"\n        enabled: True\n        publish_voxel_map: False\n        origin_z: 0.0\n        z_resolution: 0.2\n        z_voxels: 10\n        max_obstacle_height: 2.0\n        mark_threshold: 0\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 1.0\n      publish_frequency: 1.0\n      global_frame: map\n      robot_base_frame: base_link\n      use_sim_time: False\n      robot_radius: 0.3 # Larger for humanoid safety\n      resolution: 0.1\n      track_unknown_space: true\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\n      obstacle_layer:\n        plugin: "nav2_costmap_2d::ObstacleLayer"\n        enabled: True\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n      static_layer:\n        plugin: "nav2_costmap_2d::StaticLayer"\n        map_subscribe_transient_local: True\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.6\n\nplanner_server:\n  ros__parameters:\n    expected_planner_frequency: 2.0\n    use_sim_time: False\n    planner_plugins: ["HumanoidPlanner"]\n    HumanoidPlanner:\n      plugin: "humanoid_nav2_planners::HumanoidFootstepPlanner"\n      # Footstep planner parameters\n      step_size: 0.3\n      max_step_size: 0.4\n      min_step_size: 0.1\n      step_rotation: 0.3\n      max_step_rotation: 0.5\n      max_com_distance: 0.15  # Maximum CoM deviation\n      balance_threshold: 0.1  # Balance safety margin\n      # Planning parameters\n      tolerance: 0.5\n      use_astar: true\n      allow_unknown: false\n\nsmoother_server:\n  ros__parameters:\n    use_sim_time: False\n    smoother_plugins: ["simple_smoother"]\n    simple_smoother:\n      plugin: "nav2_smoother::SimpleSmoother"\n      tolerance: 1.0e-10\n      max_its: 1000\n      do_refinement: True\n\nbehavior_server:\n  ros__parameters:\n    costmap_topic: local_costmap/costmap_raw\n    footprint_topic: local_costmap/published_footprint\n    cycle_frequency: 10.0\n    behavior_plugins: ["spin", "backup", "drive_on_heading", "wait"]\n    spin:\n      plugin: "nav2_behaviors/Spin"\n      spin_dist: 1.57\n    backup:\n      plugin: "nav2_behaviors/BackUp"\n      backup_dist: 0.15  # Shorter backup for humanoid\n      backup_speed: 0.05\n    drive_on_heading:\n      plugin: "nav2_behaviors/DriveOnHeading"\n      drive_on_heading_timeout: 5.0\n      drive_on_heading_forward_dist: 0.5\n      drive_on_heading_angle_tol: 0.2\n    wait:\n      plugin: "nav2_behaviors/Wait"\n      wait_duration: 1.0\n\nwaypoint_follower:\n  ros__parameters:\n    loop_rate: 20\n    stop_on_failure: false\n    waypoint_task_executor_plugin: "wait_at_waypoint"\n    wait_at_waypoint:\n      plugin: "nav2_waypoint_follower::WaitAtWaypoint"\n      enabled: true\n      wait_time: 1.0\n'})}),"\n",(0,t.jsx)(e.h3,{id:"humanoid-footstep-planner-implementation",children:"Humanoid Footstep Planner Implementation"}),"\n",(0,t.jsxs)(e.p,{children:["Create ",(0,t.jsx)(e.code,{children:"~/ros2_ws/src/humanoid_nav2/src/humanoid_footstep_planner.cpp"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <rclcpp/rclcpp.hpp>\n#include <nav2_core/global_planner.hpp>\n#include <nav2_costmap_2d/costmap_2d_ros.h>\n#include <geometry_msgs/msg/pose_stamped.hpp>\n#include <geometry_msgs/msg/point.hpp>\n#include <nav_msgs/msg/path.hpp>\n#include <tf2/LinearMath/Quaternion.h>\n#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nnamespace humanoid_nav2_planners\n{\n\nclass HumanoidFootstepPlanner : public nav2_core::GlobalPlanner\n{\npublic:\n    HumanoidFootstepPlanner() = default;\n\n    ~HumanoidFootstepPlanner() override = default;\n\n    void configure(\n        const rclcpp_lifecycle::LifecycleNode::WeakPtr & parent,\n        std::string name,\n        std::shared_ptr<tf2_ros::Buffer> tf,\n        std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros) override\n    {\n        node_ = parent.lock();\n        name_ = name;\n        tf_ = tf;\n        costmap_ = costmap_ros->getCostmap();\n        global_frame_ = costmap_ros->getGlobalFrameID();\n\n        RCLCPP_INFO(node_->get_logger(), "Configuring Humanoid Footstep Planner");\n\n        // Declare parameters\n        node_->declare_parameter(name_ + ".step_size", 0.3);\n        node_->declare_parameter(name_ + ".max_step_size", 0.4);\n        node_->declare_parameter(name_ + ".min_step_size", 0.1);\n        node_->declare_parameter(name_ + ".step_rotation", 0.3);\n        node_->declare_parameter(name_ + ".max_step_rotation", 0.5);\n        node_->declare_parameter(name_ + ".max_com_distance", 0.15);\n        node_->declare_parameter(name_ + ".balance_threshold", 0.1);\n        node_->declare_parameter(name_ + ".tolerance", 0.5);\n        node_->declare_parameter(name_ + ".use_astar", true);\n        node_->declare_parameter(name_ + ".allow_unknown", false);\n\n        // Get parameters\n        step_size_ = node_->get_parameter(name_ + ".step_size").as_double();\n        max_step_size_ = node_->get_parameter(name_ + ".max_step_size").as_double();\n        min_step_size_ = node_->get_parameter(name_ + ".min_step_size").as_double();\n        step_rotation_ = node_->get_parameter(name_ + ".step_rotation").as_double();\n        max_step_rotation_ = node_->get_parameter(name_ + ".max_step_rotation").as_double();\n        max_com_distance_ = node_->get_parameter(name_ + ".max_com_distance").as_double();\n        balance_threshold_ = node_->get_parameter(name_ + ".balance_threshold").as_double();\n        tolerance_ = node_->get_parameter(name_ + ".tolerance").as_double();\n        use_astar_ = node_->get_parameter(name_ + ".use_astar").as_bool();\n        allow_unknown_ = node_->get_parameter(name_ + ".allow_unknown").as_bool();\n\n        RCLCPP_INFO(node_->get_logger(),\n            "Humanoid Footstep Planner configured with step_size: %.2f, max_com_distance: %.2f",\n            step_size_, max_com_distance_);\n    }\n\n    void cleanup() override\n    {\n        RCLCPP_INFO(node_->get_logger(), "Cleaning up Humanoid Footstep Planner");\n    }\n\n    void activate() override\n    {\n        RCLCPP_INFO(node_->get_logger(), "Activating Humanoid Footstep Planner");\n    }\n\n    void deactivate() override\n    {\n        RCLCPP_INFO(node_->get_logger(), "Deactivating Humanoid Footstep Planner");\n    }\n\n    nav_msgs::msg::Path createPlan(\n        const geometry_msgs::msg::PoseStamped & start,\n        const geometry_msgs::msg::PoseStamped & goal) override\n    {\n        nav_msgs::msg::Path path;\n\n        // Check if start and goal are in the same frame\n        if (start.header.frame_id != goal.header.frame_id) {\n            RCLCPP_ERROR(node_->get_logger(),\n                "Start and goal frame IDs do not match: %s vs %s",\n                start.header.frame_id.c_str(), goal.header.frame_id.c_str());\n            return path;\n        }\n\n        // Convert poses to costmap coordinates\n        double start_x, start_y, goal_x, goal_y;\n        costmap_->worldToMap(start.pose.position.x, start.pose.position.y, start_m_x_, start_m_y_);\n        costmap_->worldToMap(goal.pose.position.x, goal.pose.position.y, goal_m_x_, goal_m_y_);\n\n        // Check if start and goal are valid (not in obstacle space)\n        unsigned char start_cost = costmap_->getCost(start_m_x_, start_m_y_);\n        unsigned char goal_cost = costmap_->getCost(goal_m_x_, goal_m_y_);\n\n        if (start_cost == nav2_costmap_2d::LETHAL_OBSTACLE) {\n            RCLCPP_WARN(node_->get_logger(), "Start point is in an obstacle space");\n            return path;\n        }\n\n        if (goal_cost == nav2_costmap_2d::LETHAL_OBSTACLE) {\n            RCLCPP_WARN(node_->get_logger(), "Goal point is in an obstacle space");\n            return path;\n        }\n\n        // Plan the path using humanoid-specific constraints\n        if (!planFootsteps(start, goal, path)) {\n            RCLCPP_WARN(node_->get_logger(), "Failed to plan footsteps");\n            return path;\n        }\n\n        RCLCPP_INFO(node_->get_logger(), "Successfully planned path with %zu steps", path.poses.size());\n        return path;\n    }\n\nprivate:\n    bool planFootsteps(\n        const geometry_msgs::msg::PoseStamped & start,\n        const geometry_msgs::msg::PoseStamped & goal,\n        nav_msgs::msg::Path & path)\n    {\n        path.header.frame_id = global_frame_;\n        path.header.stamp = node_->now();\n\n        // For simplicity, implement a basic A* with humanoid constraints\n        // In a real implementation, this would use a proper footstep planning algorithm\n        std::vector<geometry_msgs::msg::PoseStamped> footsteps;\n\n        // Calculate direction to goal\n        double dx = goal.pose.position.x - start.pose.position.x;\n        double dy = goal.pose.position.y - start.pose.position.y;\n        double distance = std::sqrt(dx*dx + dy*dy);\n        double angle = std::atan2(dy, dx);\n\n        // Generate footsteps along the path\n        int num_steps = static_cast<int>(distance / step_size_) + 1;\n\n        for (int i = 0; i <= num_steps; ++i) {\n            double progress = static_cast<double>(i) / num_steps;\n            geometry_msgs::msg::PoseStamped step_pose = start;\n\n            // Interpolate position\n            step_pose.pose.position.x = start.pose.position.x + progress * dx;\n            step_pose.pose.position.y = start.pose.position.y + progress * dy;\n\n            // Set orientation to face direction of movement\n            tf2::Quaternion quat;\n            quat.setRPY(0, 0, angle);\n            step_pose.pose.orientation = tf2::toMsg(quat);\n\n            // Add to footsteps if it\'s a valid position for humanoid\n            if (isValidFootstepPosition(step_pose.pose.position.x, step_pose.pose.position.y)) {\n                footsteps.push_back(step_pose);\n            } else {\n                RCLCPP_WARN(node_->get_logger(), "Footstep at (%.2f, %.2f) is invalid",\n                           step_pose.pose.position.x, step_pose.pose.position.y);\n                // Try to find an alternative position nearby\n                if (!findAlternativeFootstep(step_pose, footsteps)) {\n                    RCLCPP_ERROR(node_->get_logger(), "Could not find valid alternative footstep");\n                    return false;\n                }\n            }\n        }\n\n        // Add final goal position if it\'s close enough to the last footstep\n        double final_dx = goal.pose.position.x - footsteps.back().pose.position.x;\n        double final_dy = goal.pose.position.y - footsteps.back().pose.position.y;\n        double final_distance = std::sqrt(final_dx*final_dx + final_dy*final_dy);\n\n        if (final_distance > tolerance_) {\n            // Add goal as final step if valid\n            if (isValidFootstepPosition(goal.pose.position.x, goal.pose.position.y)) {\n                footsteps.push_back(goal);\n            } else {\n                RCLCPP_WARN(node_->get_logger(), "Goal position is invalid, using closest valid position");\n                // Find closest valid position to goal\n                geometry_msgs::msg::Point valid_goal = findValidPositionNear(goal.pose.position);\n                if (isValidFootstepPosition(valid_goal.x, valid_goal.y)) {\n                    geometry_msgs::msg::PoseStamped valid_goal_pose = goal;\n                    valid_goal_pose.pose.position = valid_goal;\n                    footsteps.push_back(valid_goal_pose);\n                }\n            }\n        }\n\n        // Convert footsteps to path\n        for (auto& step : footsteps) {\n            path.poses.push_back(step.pose);\n        }\n\n        return true;\n    }\n\n    bool isValidFootstepPosition(double x, double y)\n    {\n        unsigned int mx, my;\n        if (!costmap_->worldToMap(x, y, mx, my)) {\n            return false; // Position is outside costmap\n        }\n\n        unsigned char cost = costmap_->getCost(mx, my);\n\n        // Check if position is traversable (not lethal obstacle or unknown if not allowed)\n        if (cost == nav2_costmap_2d::LETHAL_OBSTACLE) {\n            return false;\n        }\n\n        if (!allow_unknown_ && cost == nav2_costmap_2d::NO_INFORMATION) {\n            return false;\n        }\n\n        // Additional humanoid-specific checks could go here\n        // For example, checking if the surface is suitable for bipedal locomotion\n\n        return true;\n    }\n\n    bool findAlternativeFootstep(const geometry_msgs::msg::PoseStamped & original_step,\n                                std::vector<geometry_msgs::msg::PoseStamped> & footsteps)\n    {\n        // Try positions in a circle around the original position\n        double step_size = 0.1; // Smaller search step\n        for (double r = step_size; r <= 2.0 * step_size_; r += step_size) {\n            for (double theta = 0; theta < 2 * M_PI; theta += M_PI/4) {\n                double alt_x = original_step.pose.position.x + r * cos(theta);\n                double alt_y = original_step.pose.position.y + r * sin(theta);\n\n                if (isValidFootstepPosition(alt_x, alt_y)) {\n                    geometry_msgs::msg::PoseStamped alt_step = original_step;\n                    alt_step.pose.position.x = alt_x;\n                    alt_step.pose.position.y = alt_y;\n                    footsteps.push_back(alt_step);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    geometry_msgs::msg::Point findValidPositionNear(const geometry_msgs::msg::Point & original)\n    {\n        geometry_msgs::msg::Point valid_pos = original;\n\n        // Try to find a valid position near the original\n        double search_radius = 0.5;\n        double resolution = 0.1;\n\n        for (double r = resolution; r <= search_radius; r += resolution) {\n            for (double theta = 0; theta < 2 * M_PI; theta += M_PI/8) {\n                double x = original.x + r * cos(theta);\n                double y = original.y + r * sin(theta);\n\n                if (isValidFootstepPosition(x, y)) {\n                    valid_pos.x = x;\n                    valid_pos.y = y;\n                    return valid_pos;\n                }\n            }\n        }\n\n        // If no valid position found, return original (will likely fail)\n        return original;\n    }\n\n    // ROS components\n    rclcpp_lifecycle::LifecycleNode::SharedPtr node_;\n    std::string name_;\n    std::shared_ptr<tf2_ros::Buffer> tf_;\n    std::shared_ptr<nav2_costmap_2d::Costmap2D> costmap_;\n    std::string global_frame_;\n\n    // Parameters\n    double step_size_;\n    double max_step_size_;\n    double min_step_size_;\n    double step_rotation_;\n    double max_step_rotation_;\n    double max_com_distance_;\n    double balance_threshold_;\n    double tolerance_;\n    bool use_astar_;\n    bool allow_unknown_;\n\n    // Map coordinates\n    unsigned int start_m_x_, start_m_y_, goal_m_x_, goal_m_y_;\n};\n\n} // namespace humanoid_nav2_planners\n\n#include <pluginlib/class_list_macros.hpp>\nPLUGINLIB_EXPORT_CLASS(humanoid_nav2_planners::HumanoidFootstepPlanner, nav2_core::GlobalPlanner)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"humanoid-controller-implementation",children:"Humanoid Controller Implementation"}),"\n",(0,t.jsxs)(e.p,{children:["Create ",(0,t.jsx)(e.code,{children:"~/ros2_ws/src/humanoid_nav2/src/humanoid_controller.cpp"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <rclcpp/rclcpp.hpp>\n#include <nav2_core/controller.hpp>\n#include <nav_2_costmap_2d/costmap_2d_ros.h>\n#include <geometry_msgs/msg/twist.hpp>\n#include <geometry_msgs/msg/pose_stamped.hpp>\n#include <nav_msgs/msg/path.hpp>\n#include <tf2/LinearMath/Transform.h>\n#include <tf2/LinearMath/Quaternion.h>\n#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n#include <cmath>\n#include <vector>\n#include <memory>\n\nnamespace humanoid_nav2_controllers\n{\n\nclass HumanoidFootstepController : public nav2_core::Controller\n{\npublic:\n    HumanoidFootstepController() = default;\n\n    ~HumanoidFootstepController() override = default;\n\n    void configure(\n        const rclcpp_lifecycle::LifecycleNode::WeakPtr & parent,\n        std::string name,\n        std::shared_ptr<tf2_ros::Buffer> tf,\n        std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros) override\n    {\n        node_ = parent.lock();\n        name_ = name;\n        tf_ = tf;\n        costmap_ = costmap_ros->getCostmap();\n        global_frame_ = costmap_ros->getGlobalFrameID();\n\n        RCLCPP_INFO(node_->get_logger(), "Configuring Humanoid Footstep Controller");\n\n        // Declare parameters\n        node_->declare_parameter(name_ + ".max_translational_vel", 0.3);\n        node_->declare_parameter(name_ + ".max_rotational_vel", 0.3);\n        node_->declare_parameter(name_ + ".min_translational_vel", 0.05);\n        node_->declare_parameter(name_ + ".min_rotational_vel", 0.1);\n        node_->declare_parameter(name_ + ".translational_acc_lim", 0.2);\n        node_->declare_parameter(name_ + ".rotational_acc_lim", 0.3);\n        node_->declare_parameter(name_ + ".xy_goal_tolerance", 0.2);\n        node_->declare_parameter(name_ + ".yaw_goal_tolerance", 0.2);\n        node_->declare_parameter(name_ + ".stateful", true);\n        node_->declare_parameter(name_ + ".step_size", 0.3);\n        node_->declare_parameter(name_ + ".step_duration", 1.0);\n        node_->declare_parameter(name_ + ".balance_margin", 0.1);\n        node_->declare_parameter(name_ + ".foot_separation", 0.2);\n\n        // Get parameters\n        max_translational_vel_ = node_->get_parameter(name_ + ".max_translational_vel").as_double();\n        max_rotational_vel_ = node_->get_parameter(name_ + ".max_rotational_vel").as_double();\n        min_translational_vel_ = node_->get_parameter(name_ + ".min_translational_vel").as_double();\n        min_rotational_vel_ = node_->get_parameter(name_ + ".min_rotational_vel").as_double();\n        translational_acc_lim_ = node_->get_parameter(name_ + ".translational_acc_lim").as_double();\n        rotational_acc_lim_ = node_->get_parameter(name_ + ".rotational_acc_lim").as_double();\n        xy_goal_tolerance_ = node_->get_parameter(name_ + ".xy_goal_tolerance").as_double();\n        yaw_goal_tolerance_ = node_->get_parameter(name_ + ".yaw_goal_tolerance").as_double();\n        stateful_ = node_->get_parameter(name_ + ".stateful").as_bool();\n        step_size_ = node_->get_parameter(name_ + ".step_size").as_double();\n        step_duration_ = node_->get_parameter(name_ + ".step_duration").as_double();\n        balance_margin_ = node_->get_parameter(name_ + ".balance_margin").as_double();\n        foot_separation_ = node_->get_parameter(name_ + ".foot_separation").as_double();\n\n        RCLCPP_INFO(node_->get_logger(),\n            "Humanoid Controller configured with max_vel: %.2f, step_size: %.2f",\n            max_translational_vel_, step_size_);\n    }\n\n    void cleanup() override\n    {\n        RCLCPP_INFO(node_->get_logger(), "Cleaning up Humanoid Footstep Controller");\n    }\n\n    void activate() override\n    {\n        RCLCPP_INFO(node_->get_logger(), "Activating Humanoid Footstep Controller");\n    }\n\n    void deactivate() override\n    {\n        RCLCPP_INFO(node_->get_logger(), "Deactivating Humanoid Footstep Controller");\n    }\n\n    void setPlan(const nav_msgs::msg::Path & path) override\n    {\n        RCLCPP_INFO(node_->get_logger(), "Setting plan with %zu waypoints", path.poses.size());\n\n        global_plan_ = path;\n        current_waypoint_ = 0;\n\n        // Convert global plan to footstep sequence\n        convertToFootsteps(path);\n    }\n\n    geometry_msgs::msg::Twist computeVelocityCommands(\n        const geometry_msgs::msg::PoseStamped & pose,\n        const geometry_msgs::msg::Twist & velocity) override\n    {\n        geometry_msgs::msg::Twist cmd_vel;\n\n        if (global_plan_.poses.empty()) {\n            RCLCPP_WARN(node_->get_logger(), "No global plan provided");\n            return cmd_vel;\n        }\n\n        // Check if we\'ve reached the goal\n        if (isGoalReached(pose)) {\n            RCLCPP_INFO(node_->get_logger(), "Goal reached!");\n            return cmd_vel; // Zero velocity\n        }\n\n        // Get the next waypoint to follow\n        geometry_msgs::msg::PoseStamped target_pose;\n        if (getClosestWaypoint(pose, target_pose)) {\n            // Compute velocity command to reach target pose\n            cmd_vel = computeVelocityToTarget(pose, target_pose, velocity);\n        } else {\n            RCLCPP_WARN(node_->get_logger(), "Could not find valid target waypoint");\n            // Stop the robot\n            cmd_vel.linear.x = 0.0;\n            cmd_vel.angular.z = 0.0;\n        }\n\n        return cmd_vel;\n    }\n\n    bool isGoalReached() override\n    {\n        // This will be called from the behavior tree\n        return is_goal_reached_;\n    }\n\nprivate:\n    bool isGoalReached(const geometry_msgs::msg::PoseStamped & current_pose)\n    {\n        if (global_plan_.poses.empty()) {\n            return true;\n        }\n\n        const auto & goal_pose = global_plan_.poses.back();\n\n        double dx = current_pose.pose.position.x - goal_pose.position.x;\n        double dy = current_pose.pose.position.y - goal_pose.position.y;\n        double distance = std::sqrt(dx*dx + dy*dy);\n\n        // Calculate orientation difference\n        tf2::Quaternion current_quat, goal_quat;\n        tf2::fromMsg(current_pose.pose.orientation, current_quat);\n        tf2::fromMsg(goal_pose.orientation, goal_quat);\n\n        double current_yaw = tf2::getYaw(current_pose.pose.orientation);\n        double goal_yaw = tf2::getYaw(goal_pose.orientation);\n        double yaw_diff = std::abs(current_yaw - goal_yaw);\n\n        // Normalize yaw difference\n        while (yaw_diff > M_PI) yaw_diff -= 2 * M_PI;\n        while (yaw_diff < -M_PI) yaw_diff += 2 * M_PI;\n        yaw_diff = std::abs(yaw_diff);\n\n        bool reached = (distance <= xy_goal_tolerance_) && (yaw_diff <= yaw_goal_tolerance_);\n\n        if (reached) {\n            is_goal_reached_ = true;\n        }\n\n        return reached;\n    }\n\n    bool getClosestWaypoint(\n        const geometry_msgs::msg::PoseStamped & current_pose,\n        geometry_msgs::msg::PoseStamped & target_pose)\n    {\n        if (global_plan_.poses.empty()) {\n            return false;\n        }\n\n        // Find the closest waypoint ahead in the path\n        double min_distance = std::numeric_limits<double>::max();\n        int closest_idx = -1;\n\n        for (size_t i = current_waypoint_; i < global_plan_.poses.size(); ++i) {\n            double dx = current_pose.pose.position.x - global_plan_.poses[i].position.x;\n            double dy = current_pose.pose.position.y - global_plan_.poses[i].position.y;\n            double distance = std::sqrt(dx*dx + dy*dy);\n\n            if (distance < min_distance) {\n                min_distance = distance;\n                closest_idx = static_cast<int>(i);\n            }\n        }\n\n        if (closest_idx >= 0) {\n            target_pose.header = global_plan_.header;\n            target_pose.pose = global_plan_.poses[closest_idx];\n\n            // Look ahead to next waypoint for smoother following\n            int next_idx = std::min(closest_idx + 1, static_cast<int>(global_plan_.poses.size() - 1));\n            if (next_idx > closest_idx) {\n                target_pose.pose = global_plan_.poses[next_idx];\n            }\n\n            current_waypoint_ = closest_idx;\n            return true;\n        }\n\n        return false;\n    }\n\n    geometry_msgs::msg::Twist computeVelocityToTarget(\n        const geometry_msgs::msg::PoseStamped & current_pose,\n        const geometry_msgs::msg::PoseStamped & target_pose,\n        const geometry_msgs::msg::Twist & current_velocity)\n    {\n        geometry_msgs::msg::Twist cmd_vel;\n\n        // Calculate error to target\n        double dx = target_pose.pose.position.x - current_pose.pose.position.x;\n        double dy = target_pose.pose.position.y - current_pose.pose.position.y;\n        double distance = std::sqrt(dx*dx + dy*dy);\n\n        // Calculate target angle\n        double target_angle = std::atan2(dy, dx);\n\n        // Get current orientation\n        double current_yaw = tf2::getYaw(current_pose.pose.orientation);\n\n        // Calculate angle error\n        double angle_error = target_angle - current_yaw;\n        while (angle_error > M_PI) angle_error -= 2 * M_PI;\n        while (angle_error < -M_PI) angle_error += 2 * M_PI;\n\n        // Humanoid-specific velocity computation\n        // Use PID-like approach but constrained by humanoid capabilities\n        double linear_vel = 0.0;\n        double angular_vel = 0.0;\n\n        // Compute linear velocity based on distance to target\n        if (distance > 0.1) {  // Only move if significantly far from target\n            linear_vel = std::min(max_translational_vel_, distance * 1.0); // Proportional control\n            linear_vel = std::max(min_translational_vel_, linear_vel); // Minimum velocity\n        }\n\n        // Compute angular velocity based on angle error\n        angular_vel = angle_error * 1.0; // Proportional control\n        angular_vel = std::max(-max_rotational_vel_, std::min(max_rotational_vel_, angular_vel));\n\n        // Apply humanoid-specific constraints\n        // Limit velocities to ensure stable walking\n        linear_vel = std::min(linear_vel, max_translational_vel_);\n        angular_vel = std::min(std::abs(angular_vel), max_rotational_vel_) *\n                     (angular_vel >= 0 ? 1 : -1);\n\n        // Ensure minimum velocities to overcome static friction\n        if (std::abs(linear_vel) < min_translational_vel_ && std::abs(linear_vel) > 0.001) {\n            linear_vel = (linear_vel >= 0 ? 1 : -1) * min_translational_vel_;\n        }\n\n        if (std::abs(angular_vel) < min_rotational_vel_ && std::abs(angular_vel) > 0.001) {\n            angular_vel = (angular_vel >= 0 ? 1 : -1) * min_rotational_vel_;\n        }\n\n        cmd_vel.linear.x = linear_vel;\n        cmd_vel.angular.z = angular_vel;\n\n        // Log for debugging\n        RCLCPP_DEBUG(node_->get_logger(),\n            "Target: (%.2f, %.2f), Current: (%.2f, %.2f), Cmd: (%.2f, %.2f)",\n            target_pose.pose.position.x, target_pose.pose.position.y,\n            current_pose.pose.position.x, current_pose.pose.position.y,\n            cmd_vel.linear.x, cmd_vel.angular.z);\n\n        return cmd_vel;\n    }\n\n    void convertToFootsteps(const nav_msgs::msg::Path & path)\n    {\n        // Convert the global path to a sequence of footsteps\n        // This is a simplified version - in reality, this would involve complex footstep planning\n        footsteps_.clear();\n\n        if (path.poses.size() < 2) {\n            return;\n        }\n\n        // For each segment of the path, generate appropriate footsteps\n        for (size_t i = 0; i < path.poses.size() - 1; ++i) {\n            // Calculate direction and distance between consecutive waypoints\n            double dx = path.poses[i+1].position.x - path.poses[i].position.x;\n            double dy = path.poses[i+1].position.y - path.poses[i].position.y;\n            double dist = std::sqrt(dx*dx + dy*dy);\n\n            // Generate footsteps along this segment based on step size\n            int steps_in_segment = static_cast<int>(dist / step_size_) + 1;\n\n            for (int j = 0; j <= steps_in_segment; ++j) {\n                double progress = static_cast<double>(j) / steps_in_segment;\n\n                geometry_msgs::msg::PoseStamped footstep;\n                footstep.header = path.header;\n                footstep.pose.position.x = path.poses[i].position.x + progress * dx;\n                footstep.pose.position.y = path.poses[i].position.y + progress * dy;\n                footstep.pose.position.z = 0.0; // Ground level\n\n                // Set orientation to match path direction\n                tf2::Quaternion quat;\n                double angle = std::atan2(dy, dx);\n                quat.setRPY(0, 0, angle);\n                footstep.pose.orientation = tf2::toMsg(quat);\n\n                footsteps_.push_back(footstep);\n            }\n        }\n    }\n\n    // ROS components\n    rclcpp_lifecycle::LifecycleNode::SharedPtr node_;\n    std::string name_;\n    std::shared_ptr<tf2_ros::Buffer> tf_;\n    std::shared_ptr<nav2_costmap_2d::Costmap2D> costmap_;\n    std::string global_frame_;\n\n    // Parameters\n    double max_translational_vel_;\n    double max_rotational_vel_;\n    double min_translational_vel_;\n    double min_rotational_vel_;\n    double translational_acc_lim_;\n    double rotational_acc_lim_;\n    double xy_goal_tolerance_;\n    double yaw_goal_tolerance_;\n    bool stateful_;\n    double step_size_;\n    double step_duration_;\n    double balance_margin_;\n    double foot_separation_;\n\n    // State\n    nav_msgs::msg::Path global_plan_;\n    std::vector<geometry_msgs::msg::PoseStamped> footsteps_;\n    size_t current_waypoint_;\n    bool is_goal_reached_ = false;\n};\n\n} // namespace humanoid_nav2_controllers\n\n#include <pluginlib/class_list_macros.hpp>\nPLUGINLIB_EXPORT_CLASS(humanoid_nav2_controllers::HumanoidFootstepController, nav2_core::Controller)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"nav2-behavior-tree-for-humanoid-navigation",children:"Nav2 Behavior Tree for Humanoid Navigation"}),"\n",(0,t.jsxs)(e.p,{children:["Create ",(0,t.jsx)(e.code,{children:"~/ros2_ws/src/humanoid_nav2/behavior_trees/humanoid_navigate_to_pose_w_replanning_and_recovery.xml"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<root main_tree_to_execute="MainTree">\n    <BehaviorTree ID="MainTree">\n        <SequenceStar name="NavigateToPose">\n            <GoalUpdated/>\n            <ClearEntireCostmap name="ClearGlobalCostmap-Context"/>\n            <RecoveryNode number_of_retries="6" name="NavigateRecovery">\n                <PipelineSequence name="NavigateWithReplanning">\n                    <RateController hz="1.0">\n                        <RecoveryNode number_of_retries="1" name="ComputePathToPose">\n                            <ComputePathToPose goal="{goal}" path="{path}" planner_id="HumanoidPlanner"/>\n                            <PlanRootSelector>\n                                <ReactiveSequence>\n                                    <IsPathValid path="{path}"/>\n                                </ReactiveSequence>\n                                <ReactiveFallback name="ComputePathToPoseRecoveryFallback">\n                                    <RecoveryNode number_of_retries="1" name="ClearForPath">\n                                        <ClearEntireCostmap name="ClearGlobalCostmap-Path" service_name="global_costmap/clear_entirely_global_costmap"/>\n                                        <ComputePathToPose goal="{goal}" path="{path}" planner_id="HumanoidPlanner"/>\n                                    </RecoveryNode>\n                                    <ComputePathToPose goal="{goal}" path="{path}" planner_id="HumanoidPlanner"/>\n                                </ReactiveFallback>\n                            </PlanRootSelector>\n                        </RecoveryNode>\n                    </RateController>\n                    <RateController hz="20.0">\n                        <RecoveryNode number_of_retries="2" name="FollowPath">\n                            <FollowPath path="{path}" controller_id="HumanoidController"/>\n                            <PlanRootSelector>\n                                <ReactiveSequence>\n                                    <IsPathValid path="{path}"/>\n                                </ReactiveSequence>\n                                <ReactiveFallback name="FollowPathRecoveryFallback">\n                                    <RecoveryNode number_of_retries="1" name="ClearAroundRobot">\n                                        <ClearCostmapAroundRobot name="ClearLocalCostmap-AroundRobot" service_name="local_costmap/clear_costmap_around_robot"/>\n                                        <FollowPath path="{path}" controller_id="HumanoidController"/>\n                                    </RecoveryNode>\n                                    <ClearEntireCostmap name="ClearLocalCostmap-Path" service_name="local_costmap/clear_entirely_local_costmap"/>\n                                </ReactiveFallback>\n                            </PlanRootSelector>\n                        </RecoveryNode>\n                    </RateController>\n                </PipelineSequence>\n                <ReactiveFallback name="RecoveryFallback">\n                    <GoalUpdated/>\n                    <RecoveryNode number_of_retries="1" name="Backup">\n                        <BackUp distance="0.15" backup_speed="0.05"/>\n                    </RecoveryNode>\n                    <Wait wait_duration="5"/>\n                </ReactiveFallback>\n            </RecoveryNode>\n        </SequenceStar>\n    </BehaviorTree>\n</root>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"active-learning-exercise",children:"Active Learning Exercise"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Exercise: Humanoid Navigation with Balance Constraints"})}),"\n",(0,t.jsx)(e.p,{children:"Design and implement a navigation system that incorporates balance constraints for a humanoid robot:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Create a balance-aware costmap layer that considers terrain slope and roughness"}),"\n",(0,t.jsx)(e.li,{children:"Implement a footstep planner that ensures the robot's center of mass remains within stable regions"}),"\n",(0,t.jsx)(e.li,{children:"Design a controller that adjusts gait parameters based on terrain characteristics"}),"\n",(0,t.jsx)(e.li,{children:"Test your system with different terrain types (flat, sloped, rough)"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Consider how different walking patterns (slow careful steps vs. normal walking) would affect navigation performance and safety."}),"\n",(0,t.jsx)(e.h2,{id:"worked-example-black-box-to-glass-box---humanoid-navigation-system",children:"Worked Example: Black-box to Glass-box - Humanoid Navigation System"}),"\n",(0,t.jsx)(e.h3,{id:"black-box-view",children:"Black-box View"}),"\n",(0,t.jsx)(e.p,{children:"We'll create a complete humanoid navigation system that takes a goal pose and safely navigates the humanoid robot to that location while maintaining balance and avoiding obstacles. The black-box view is: the system receives a goal and outputs appropriate footstep commands to reach the destination."}),"\n",(0,t.jsx)(e.h3,{id:"glass-box-implementation",children:"Glass-box Implementation"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Complete system architecture:"})}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"The implementation includes:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Custom Nav2 configuration for humanoid robots"}),"\n",(0,t.jsx)(e.li,{children:"Footstep planner with balance constraints"}),"\n",(0,t.jsx)(e.li,{children:"Humanoid-specific controller with gait parameters"}),"\n",(0,t.jsx)(e.li,{children:"Behavior tree for navigation with recovery behaviors"}),"\n",(0,t.jsx)(e.li,{children:"Integration with robot's balance control system"}),"\n"]}),"\n",(0,t.jsxs)(e.ol,{start:"2",children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Balance-aware navigation:"})}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Example of balance-aware path planning (conceptual)\nclass BalanceAwarePathPlanner {\npublic:\n    bool planPathWithBalanceConstraints(\n        const geometry_msgs::msg::Pose& start,\n        const geometry_msgs::msg::Pose& goal,\n        nav_msgs::msg::Path& path)\n    {\n        // Calculate potential support polygon based on foot positions\n        SupportPolygon support_poly = calculateSupportPolygon(start);\n\n        // Plan path ensuring CoM stays within support polygon with safety margin\n        std::vector<geometry_msgs::msg::Pose> footsteps;\n\n        // Use A* or other algorithm with balance constraints\n        if (!balanceConstrainedAStar(start, goal, support_poly, footsteps)) {\n            return false;\n        }\n\n        // Convert to Nav2 path format\n        convertToNavPath(footsteps, path);\n        return true;\n    }\n\nprivate:\n    struct SupportPolygon {\n        std::vector<geometry_msgs::msg::Point> vertices;\n        geometry_msgs::msg::Point center_of_pressure;\n        double safety_margin;\n    };\n\n    SupportPolygon calculateSupportPolygon(const geometry_msgs::msg::Pose& robot_pose) {\n        // Calculate support polygon based on current foot positions\n        // This would consider the robot's current stance\n        SupportPolygon poly;\n\n        // For a biped, the support polygon is typically between the feet\n        geometry_msgs::msg::Point left_foot, right_foot;\n        // Calculate foot positions based on robot pose and stance\n        calculateFootPositions(robot_pose, left_foot, right_foot);\n\n        // Create convex hull of support polygon\n        poly.vertices = {left_foot, right_foot}; // Simplified for example\n        poly.center_of_pressure.x = (left_foot.x + right_foot.x) / 2.0;\n        poly.center_of_pressure.y = (left_foot.y + right_foot.y) / 2.0;\n        poly.safety_margin = 0.1; // Safety margin around support polygon\n\n        return poly;\n    }\n\n    bool balanceConstrainedAStar(\n        const geometry_msgs::msg::Pose& start,\n        const geometry_msgs::msg::Pose& goal,\n        const SupportPolygon& support_poly,\n        std::vector<geometry_msgs::msg::Pose>& footsteps)\n    {\n        // Implementation of A* algorithm with balance constraints\n        // Each potential footstep must maintain CoM within support polygon\n        // with appropriate safety margins\n        return true; // Simplified implementation\n    }\n};\n"})}),"\n",(0,t.jsxs)(e.ol,{start:"3",children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Gait adaptation:"})}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"The system adapts gait parameters based on:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Terrain characteristics (roughness, slope)"}),"\n",(0,t.jsx)(e.li,{children:"Obstacle proximity"}),"\n",(0,t.jsx)(e.li,{children:"Balance state"}),"\n",(0,t.jsx)(e.li,{children:"Navigation urgency"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"understanding-the-implementation",children:"Understanding the Implementation"}),"\n",(0,t.jsx)(e.p,{children:"The glass-box view reveals:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"The navigation system integrates balance constraints with traditional path planning"}),"\n",(0,t.jsx)(e.li,{children:"Footstep planning considers both obstacle avoidance and dynamic stability"}),"\n",(0,t.jsx)(e.li,{children:"The controller adapts gait parameters in real-time based on environmental conditions"}),"\n",(0,t.jsx)(e.li,{children:"Recovery behaviors are specialized for humanoid robots' unique capabilities and limitations"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"tiered-assessments",children:"Tiered Assessments"}),"\n",(0,t.jsx)(e.h3,{id:"tier-1-basic-understanding",children:"Tier 1: Basic Understanding"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"What are the main differences between wheeled robot navigation and bipedal humanoid navigation?"}),"\n",(0,t.jsx)(e.li,{children:"Name three balance-related constraints that affect humanoid navigation."}),"\n",(0,t.jsx)(e.li,{children:"What is the Zero Moment Point (ZMP) and why is it important for humanoid robots?"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"tier-2-application",children:"Tier 2: Application"}),"\n",(0,t.jsxs)(e.ol,{start:"4",children:["\n",(0,t.jsx)(e.li,{children:"Configure Nav2 with custom parameters suitable for a humanoid robot's navigation requirements."}),"\n",(0,t.jsx)(e.li,{children:"Implement a basic footstep planner that considers simple balance constraints."}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"tier-3-analysis-and-synthesis",children:"Tier 3: Analysis and Synthesis"}),"\n",(0,t.jsxs)(e.ol,{start:"6",children:["\n",(0,t.jsx)(e.li,{children:"Design a complete navigation system for a humanoid robot that integrates balance control, terrain analysis, and dynamic gait adaptation for robust navigation in complex environments."}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"mermaid-diagram",children:"Mermaid Diagram"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-mermaid",children:"graph TB\n    A[Goal Pose] --\x3e B[Global Path Planner]\n    B --\x3e C[Humanoid Footstep Planner]\n\n    D[Robot State] --\x3e E[Balance Controller]\n    D --\x3e F[Odometry]\n\n    E --\x3e C\n    F --\x3e G[Local Path Following]\n\n    C --\x3e G\n    G --\x3e H[Humanoid Controller]\n\n    H --\x3e I[Step Commands]\n    I --\x3e J[Robot Hardware]\n\n    J --\x3e K[Sensor Feedback]\n    K --\x3e L[State Estimation]\n    L --\x3e D\n\n    G --\x3e M[Obstacle Detection]\n    M --\x3e N[Local Replanning]\n    N --\x3e G\n\n    H --\x3e O[Gait Adaptation]\n    O --\x3e H\n\n    style A fill:#ff9999\n    style J fill:#99ccff\n    style G fill:#99ff99\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Alt-text for diagram:"}),' "Humanoid navigation system architecture showing goal pose input flowing to global path planner, which connects to humanoid footstep planner. Robot state connects to balance controller and odometry, with balance controller connecting to footstep planner. Odometry and footstep planner connect to local path following, which connects to humanoid controller. The controller outputs step commands to robot hardware. The hardware provides sensor feedback to state estimation, which updates the robot state. Local path following also connects to obstacle detection and local replanning, which feeds back to path following. The controller also connects to gait adaptation, which feeds back to the controller. The goal is highlighted in pink, robot hardware in light blue, and navigation components in light green."']}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"This chapter covered the adaptation of Nav2 for bipedal humanoid robot navigation, addressing the unique challenges of balance, stability, and locomotion patterns. We explored the theoretical foundations of bipedal navigation, implemented custom Nav2 components for humanoid robots, and demonstrated how to integrate balance constraints with traditional navigation planning. The examples showed how to create a complete navigation system that ensures both obstacle avoidance and dynamic stability for humanoid robots."}),"\n",(0,t.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Siciliano, B., & Khatib, O. (2016). Springer handbook of robotics. Springer Publishing Company, Incorporated."}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["Khatib, O., Park, H. W., Verrelst, B., Kim, B. S., Dalloul, I., & Yokoi, K. (2016). Humanoid robot control system framework for supporting different programming methods. ",(0,t.jsx)(e.em,{children:"2016 IEEE-RAS 16th International Conference on Humanoid Robots (Humanoids)"}),", 83-88."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["Ha, I., Tamura, Y., Asama, H., &\u767d\u4e91, J. (2015). Real-time walking pattern generation based on control of the zero-moment point for a full-size humanoid robot. ",(0,t.jsx)(e.em,{children:"Advanced Robotics"}),", 29(1), 1-14."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["Wensing, P. M., & Orin, D. E. (2013). Improved computation of the moment centroidal dynamics and application to the control of humanoid robots. ",(0,t.jsx)(e.em,{children:"International Journal of Humanoid Robotics"}),", 10(01), 1350007."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["Herdt, A., von Hoyningen-Huene, J. R., & Burgard, W. (2010). Planning walking patterns for humanoid robots with kinematic and dynamic constraints. ",(0,t.jsx)(e.em,{children:"2010 IEEE/RSJ International Conference on Intelligent Robots and Systems"}),", 34-40."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["Caron, S., Pham, Q. C., & Nakamura, Y. (2019). Locomotion planning with dynamically-consistent optimization-based control. ",(0,t.jsx)(e.em,{children:"2019 International Conference on Robotics and Automation (ICRA)"}),", 7976-7982."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["Mastalli, M., Budhiraja, R., Merkt, W., Chen, J., Ram\xedrez, I., Hammoud, B., ... & Vijayakumar, S. (2020). Crocoddyl: An efficient and versatile framework for multi-contact optimal control. ",(0,t.jsx)(e.em,{children:"2020 IEEE International Conference on Robotics and Automation (ICRA)"}),", 944-950."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["Nava, G., Romano, F., Dafarra, S., Pucci, D., Haddadin, S., & Nori, F. (2016). Stable walking with multiple step time and step length variations. ",(0,t.jsx)(e.em,{children:"2016 IEEE-RAS 16th International Conference on Humanoid Robots (Humanoids)"}),", 307-314."]}),"\n"]}),"\n"]})]})}function c(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}}}]);