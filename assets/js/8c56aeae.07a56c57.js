"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[81],{8001:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>t,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"digital-twin/gazebo-physics-and-world-building","title":"Gazebo Physics & World Building","description":"Learning Objectives","source":"@site/docs/02-digital-twin/01-gazebo-physics-and-world-building.md","sourceDirName":"02-digital-twin","slug":"/digital-twin/gazebo-physics-and-world-building","permalink":"/digital-twin/gazebo-physics-and-world-building","draft":false,"unlisted":false,"editUrl":"https://github.com/mfsrajput/AI-And-Robotic-Hackathoon/edit/main/docs/02-digital-twin/01-gazebo-physics-and-world-building.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Gazebo Physics & World Building"},"sidebar":"moduleSidebar","previous":{"title":"Python rclpy Bridge to Controllers","permalink":"/ros2/python-rclpy-bridge"},"next":{"title":"Sensor Simulation (LiDAR, Depth, IMU)","permalink":"/digital-twin/simulating-sensors-lidar-imu-depth"}}');var s=i(4848),a=i(8453);const t={sidebar_position:1,title:"Gazebo Physics & World Building"},r="Gazebo Physics & World Building",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Theory: Physics Simulation Fundamentals",id:"theory-physics-simulation-fundamentals",level:2},{value:"Rigid Body Dynamics",id:"rigid-body-dynamics",level:3},{value:"Contact Physics",id:"contact-physics",level:3},{value:"Sensor Simulation",id:"sensor-simulation",level:3},{value:"Practice: Creating a Gazebo World for Humanoid Robotics",id:"practice-creating-a-gazebo-world-for-humanoid-robotics",level:2},{value:"Basic World Structure",id:"basic-world-structure",level:3},{value:"Creating a Humanoid Robot Model for Gazebo",id:"creating-a-humanoid-robot-model-for-gazebo",level:3},{value:"Active Learning Exercise",id:"active-learning-exercise",level:2},{value:"Worked Example: Black-box to Glass-box - Creating a Custom Gazebo Plugin",id:"worked-example-black-box-to-glass-box---creating-a-custom-gazebo-plugin",level:2},{value:"Black-box View",id:"black-box-view",level:3},{value:"Glass-box Implementation",id:"glass-box-implementation",level:3},{value:"Understanding the Implementation",id:"understanding-the-implementation",level:3},{value:"Tiered Assessments",id:"tiered-assessments",level:2},{value:"Tier 1: Basic Understanding",id:"tier-1-basic-understanding",level:3},{value:"Tier 2: Application",id:"tier-2-application",level:3},{value:"Tier 3: Analysis and Synthesis",id:"tier-3-analysis-and-synthesis",level:3},{value:"Mermaid Diagram",id:"mermaid-diagram",level:2},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"gazebo-physics--world-building",children:"Gazebo Physics & World Building"})}),"\n",(0,s.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this chapter, students will be able to:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Design and implement physically accurate simulation environments for humanoid robots"}),"\n",(0,s.jsx)(e.li,{children:"Create complex world files with realistic physics properties and constraints"}),"\n",(0,s.jsx)(e.li,{children:"Configure Gazebo plugins for sensor simulation and robot control"}),"\n",(0,s.jsx)(e.li,{children:"Implement custom physics models for specialized humanoid robot components"}),"\n",(0,s.jsx)(e.li,{children:"Optimize simulation performance for real-time humanoid robot applications"}),"\n",(0,s.jsx)(e.li,{children:"Validate simulation accuracy against real-world robot behavior"}),"\n",(0,s.jsx)(e.li,{children:"Integrate Gazebo with ROS 2 for seamless simulation-to-reality transfer"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo stands as the premier physics simulation environment for robotics, offering realistic modeling of rigid body dynamics, contact physics, and sensor simulation. For humanoid robotics, Gazebo provides the essential capability to test complex locomotion algorithms, balance control systems, and human-robot interaction scenarios in a safe, repeatable environment before deployment on expensive hardware."}),"\n",(0,s.jsx)(e.p,{children:"The digital twin concept in robotics refers to a virtual replica of a physical robot system that mirrors its behavior, properties, and interactions in real-time. For humanoid robots, this digital twin must accurately capture complex multi-degree-of-freedom dynamics, sensor characteristics, and environmental interactions. Gazebo serves as the foundational platform for creating these digital twins, providing the physics engine, rendering capabilities, and sensor simulation necessary for realistic robot modeling."}),"\n",(0,s.jsx)(e.h2,{id:"theory-physics-simulation-fundamentals",children:"Theory: Physics Simulation Fundamentals"}),"\n",(0,s.jsx)(e.h3,{id:"rigid-body-dynamics",children:"Rigid Body Dynamics"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo's physics engine, based on ODE (Open Dynamics Engine), Bullet Physics, or DART (Dynamic Animation and Robotics Toolkit), simulates the motion of rigid bodies under the influence of forces, torques, and constraints. For humanoid robots with 20+ degrees of freedom, this involves solving complex systems of equations to determine position, velocity, and acceleration of each link."}),"\n",(0,s.jsx)(e.p,{children:"The fundamental equation governing rigid body motion is Newton-Euler equation:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Linear motion: F = ma"}),"\n",(0,s.jsx)(e.li,{children:"Angular motion: \u03c4 = I\u03b1 + \u03c9 \xd7 I\u03c9"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Where F is force, m is mass, a is acceleration, \u03c4 is torque, I is inertia tensor, \u03b1 is angular acceleration, and \u03c9 is angular velocity."}),"\n",(0,s.jsx)(e.h3,{id:"contact-physics",children:"Contact Physics"}),"\n",(0,s.jsx)(e.p,{children:"Humanoid robots interact with the environment through contact points, making accurate contact simulation crucial. Gazebo models contact forces using various parameters:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Friction coefficients (static and dynamic)"}),"\n",(0,s.jsx)(e.li,{children:"Bounce properties"}),"\n",(0,s.jsx)(e.li,{children:"Contact surface parameters"}),"\n",(0,s.jsx)(e.li,{children:"Collision detection algorithms"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo simulates various sensors commonly used in humanoid robots:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"IMU sensors for orientation and acceleration"}),"\n",(0,s.jsx)(e.li,{children:"LiDAR for environment mapping"}),"\n",(0,s.jsx)(e.li,{children:"Depth cameras for 3D perception"}),"\n",(0,s.jsx)(e.li,{children:"Force/torque sensors for contact detection"}),"\n",(0,s.jsx)(e.li,{children:"Joint position/velocity sensors"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"practice-creating-a-gazebo-world-for-humanoid-robotics",children:"Practice: Creating a Gazebo World for Humanoid Robotics"}),"\n",(0,s.jsx)(e.h3,{id:"basic-world-structure",children:"Basic World Structure"}),"\n",(0,s.jsx)(e.p,{children:"Let's create a comprehensive Gazebo world file that includes physics properties, lighting, and models:"}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"~/ros2_ws/src/humanoid_simulation/worlds/humanoid_lab.world"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="humanoid_lab">\n    \x3c!-- Physics Engine Configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000.0</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>10</iters>\n          <sor>1.3</sor>\n        </solver>\n        <constraints>\n          <cfm>0.000001</cfm>\n          <erp>0.2</erp>\n          <contact_max_correcting_vel>100</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <light name="sun" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.3 0.3 -1</direction>\n    </light>\n\n    \x3c!-- Ground Plane --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>1.0</mu>\n                <mu2>1.0</mu2>\n              </ode>\n            </friction>\n            <contact>\n              <ode>\n                <kp>1e+16</kp>\n                <kd>1e+13</kd>\n                <max_vel>100.0</max_vel>\n                <min_depth>0.001</min_depth>\n              </ode>\n            </contact>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.7 0.7 0.7 1</ambient>\n            <diffuse>0.7 0.7 0.7 1</diffuse>\n            <specular>0.0 0.0 0.0 1</specular>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Example Humanoid Robot Spawn --\x3e\n    <include>\n      <uri>model://simple_humanoid</uri>\n      <pose>0 0 0.8 0 0 0</pose>\n    </include>\n\n    \x3c!-- Obstacles and Furniture --\x3e\n    <model name="table">\n      <pose>2 0 0 0 0 0</pose>\n      <link name="table_top">\n        <pose>0 0 0.75 0 0 0</pose>\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1.5 0.8 0.05</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1.5 0.8 0.05</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.5 0.3 0.1 1</ambient>\n            <diffuse>0.5 0.3 0.1 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>20.0</mass>\n          <inertia>\n            <ixx>0.8</ixx>\n            <ixy>0.0</ixy>\n            <ixz>0.0</ixz>\n            <iyy>1.8</iyy>\n            <iyz>0.0</iyz>\n            <izz>2.4</izz>\n          </inertia>\n        </inertial>\n      </link>\n      <link name="leg1">\n        <pose>-0.6 -0.35 0.375 0 0 0</pose>\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>0.05 0.05 0.7</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>0.05 0.05 0.7</size>\n          </geometry>\n          <material>\n            <ambient>0.5 0.3 0.1 1</ambient>\n            <diffuse>0.5 0.3 0.1 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>2.0</mass>\n          <inertia>\n            <ixx>0.1</ixx>\n            <ixy>0.0</ixy>\n            <ixz>0.0</ixz>\n            <iyy>0.1</iyy>\n            <iyz>0.0</iyz>\n            <izz>0.001</izz>\n          </inertia>\n        </inertial>\n      </link>\n      <joint name="top_to_leg1" type="fixed">\n        <parent>table_top</parent>\n        <child>leg1</child>\n      </joint>\n    </model>\n\n    \x3c!-- Sample Objects for Interaction --\x3e\n    <model name="ball">\n      <pose>-1 0 1 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <sphere>\n              <radius>0.1</radius>\n            </sphere>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.5</mu>\n                <mu2>0.5</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <sphere>\n              <radius>0.1</radius>\n            </sphere>\n          </geometry>\n          <material>\n            <ambient>1 0 0 1</ambient>\n            <diffuse>1 0 0 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>0.5</mass>\n          <inertia>\n            <ixx>0.002</ixx>\n            <ixy>0.0</ixy>\n            <ixz>0.0</ixz>\n            <iyy>0.002</iyy>\n            <iyz>0.0</iyz>\n            <izz>0.002</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"creating-a-humanoid-robot-model-for-gazebo",children:"Creating a Humanoid Robot Model for Gazebo"}),"\n",(0,s.jsx)(e.p,{children:"Create the model directory and files:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"mkdir -p ~/ros2_ws/src/humanoid_simulation/models/simple_humanoid\n"})}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"~/ros2_ws/src/humanoid_simulation/models/simple_humanoid/model.sdf"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <model name="simple_humanoid">\n    <link name="base_link">\n      <pose>0 0 0.8 0 0 0</pose>\n      <inertial>\n        <mass>10.0</mass>\n        <inertia>\n          <ixx>0.1</ixx>\n          <ixy>0.0</ixy>\n          <ixz>0.0</ixz>\n          <iyy>0.1</iyy>\n          <iyz>0.0</iyz>\n          <izz>0.1</izz>\n        </inertia>\n      </inertial>\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>0.3 0.2 0.1</size>\n          </box>\n        </geometry>\n        <material>\n          <ambient>0.8 0.8 0.8 1</ambient>\n          <diffuse>0.8 0.8 0.8 1</diffuse>\n        </material>\n      </visual>\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>0.3 0.2 0.1</size>\n          </box>\n        </geometry>\n      </collision>\n    </link>\n\n    \x3c!-- Torso --\x3e\n    <link name="torso">\n      <inertial>\n        <mass>8.0</mass>\n        <inertia>\n          <ixx>0.2</ixx>\n          <ixy>0.0</ixy>\n          <ixz>0.0</ixz>\n          <iyy>0.2</iyy>\n          <iyz>0.0</iyz>\n          <izz>0.2</izz>\n        </inertia>\n      </inertial>\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>0.25 0.2 0.4</size>\n          </box>\n        </geometry>\n        <material>\n          <ambient>0.5 0.5 0.8 1</ambient>\n          <diffuse>0.5 0.5 0.8 1</diffuse>\n        </material>\n      </visual>\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>0.25 0.2 0.4</size>\n          </box>\n        </geometry>\n      </collision>\n    </link>\n\n    <joint name="base_to_torso" type="fixed">\n      <parent>base_link</parent>\n      <child>torso</child>\n      <pose>0 0 0.05 0 0 0</pose>\n    </joint>\n\n    \x3c!-- Head --\x3e\n    <link name="head">\n      <inertial>\n        <mass>2.0</mass>\n        <inertia>\n          <ixx>0.01</ixx>\n          <ixy>0.0</ixy>\n          <ixz>0.0</ixz>\n          <iyy>0.01</iyy>\n          <iyz>0.0</iyz>\n          <izz>0.01</izz>\n        </inertia>\n      </inertial>\n      <visual name="visual">\n        <geometry>\n          <sphere>\n            <radius>0.1</radius>\n          </sphere>\n        </geometry>\n        <material>\n          <ambient>0.8 0.8 0.8 1</ambient>\n          <diffuse>0.8 0.8 0.8 1</diffuse>\n        </material>\n      </visual>\n      <collision name="collision">\n        <geometry>\n          <sphere>\n            <radius>0.1</radius>\n          </sphere>\n        </geometry>\n      </collision>\n    </link>\n\n    <joint name="torso_to_head" type="revolute">\n      <parent>torso</parent>\n      <child>head</child>\n      <pose>0 0 0.2 0 0 0</pose>\n      <axis>\n        <xyz>0 1 0</xyz>\n        <limit>\n          <lower>-1.0</lower>\n          <upper>1.0</upper>\n          <effort>100</effort>\n          <velocity>1</velocity>\n        </limit>\n      </axis>\n    </joint>\n\n    \x3c!-- Left Arm --\x3e\n    <link name="left_upper_arm">\n      <inertial>\n        <mass>1.5</mass>\n        <inertia>\n          <ixx>0.01</ixx>\n          <ixy>0.0</ixy>\n          <ixz>0.0</ixz>\n          <iyy>0.01</iyy>\n          <iyz>0.0</iyz>\n          <izz>0.01</izz>\n        </inertia>\n      </inertial>\n      <visual name="visual">\n        <geometry>\n          <cylinder>\n            <radius>0.05</radius>\n            <length>0.3</length>\n          </cylinder>\n          <pose>0 0 0.15 1.5708 0 0</pose>\n        </visual>\n        <collision name="collision">\n          <geometry>\n            <cylinder>\n              <radius>0.05</radius>\n              <length>0.3</length>\n            </cylinder>\n          <pose>0 0 0.15 1.5708 0 0</pose>\n        </collision>\n      </link>\n\n      <joint name="torso_to_left_shoulder" type="revolute">\n        <parent>torso</parent>\n        <child>left_upper_arm</child>\n        <pose>0.1 0.1 0.1 0 0 0</pose>\n        <axis>\n          <xyz>0 1 0</xyz>\n          <limit>\n            <lower>-1.57</lower>\n            <upper>1.57</upper>\n            <effort>50</effort>\n            <velocity>2</velocity>\n          </limit>\n        </axis>\n      </joint>\n\n    \x3c!-- Gazebo Plugin for ROS 2 Control --\x3e\n    <gazebo>\n      <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">\n        <robotNamespace>/simple_humanoid</robotNamespace>\n      </plugin>\n    </gazebo>\n\n    \x3c!-- IMU Sensor --\x3e\n    <sensor name="imu_sensor" type="imu">\n      <always_on>true</always_on>\n      <update_rate>100</update_rate>\n      <pose>0 0 0 0 0 0</pose>\n      <plugin name="imu_plugin" filename="libgazebo_ros_imu.so">\n        <robotNamespace>/simple_humanoid</robotNamespace>\n        <topicName>imu/data</topicName>\n        <bodyName>torso</bodyName>\n        <updateRateHZ>100.0</updateRateHZ>\n        <gaussianNoise>0.001</gaussianNoise>\n        <xyz>0 0 0</xyz>\n        <rpy>0 0 0</rpy>\n      </plugin>\n    </sensor>\n\n  </model>\n</sdf>\n'})}),"\n",(0,s.jsx)(e.p,{children:"Create the model configuration file:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"~/ros2_ws/src/humanoid_simulation/models/simple_humanoid/model.config\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<model>\n  <name>Simple Humanoid</name>\n  <version>1.0</version>\n  <sdf version="1.7">model.sdf</sdf>\n  <author>\n    <name>Humanoid Robotics Lab</name>\n    <email>lab@robotics.edu</email>\n  </author>\n  <description>\n    A simple humanoid robot model for simulation in Gazebo.\n  </description>\n</model>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"active-learning-exercise",children:"Active Learning Exercise"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Exercise: Physics Parameter Tuning"})}),"\n",(0,s.jsx)(e.p,{children:"Consider the following scenario: You're designing a humanoid robot for walking on different surfaces (carpet, hardwood, grass)."}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"How would you modify the physics parameters in your Gazebo world to simulate these different surfaces?"}),"\n",(0,s.jsx)(e.li,{children:"What friction coefficients would you expect for each surface?"}),"\n",(0,s.jsx)(e.li,{children:"How might you model the compliance of grass vs. hardwood in your simulation?"}),"\n",(0,s.jsx)(e.li,{children:"Design a simple experiment to test your hypotheses by creating two different world files with different surface properties."}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Work with a partner to implement and test your solutions, then compare results."}),"\n",(0,s.jsx)(e.h2,{id:"worked-example-black-box-to-glass-box---creating-a-custom-gazebo-plugin",children:"Worked Example: Black-box to Glass-box - Creating a Custom Gazebo Plugin"}),"\n",(0,s.jsx)(e.h3,{id:"black-box-view",children:"Black-box View"}),"\n",(0,s.jsx)(e.p,{children:"We'll create a custom Gazebo plugin that simulates a force/torque sensor in the robot's foot. The black-box view is: we specify the plugin in our robot model, and it publishes force/torque data that matches what we'd expect from a real sensor when the robot walks."}),"\n",(0,s.jsx)(e.h3,{id:"glass-box-implementation",children:"Glass-box Implementation"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"Create a custom plugin directory:"})}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"mkdir -p ~/ros2_ws/src/humanoid_simulation/plugins\n"})}),"\n",(0,s.jsxs)(e.ol,{start:"2",children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"Create the force/torque sensor plugin:"})}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"~/ros2_ws/src/humanoid_simulation/plugins/force_torque_plugin.cpp"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'#include <gazebo/gazebo.hh>\n#include <gazebo/physics/physics.hh>\n#include <gazebo/transport/transport.hh>\n#include <gazebo/msgs/msgs.hh>\n#include <gazebo/common/Plugin.hh>\n#include <gazebo/common/Events.hh>\n#include <ros/ros.h>\n#include <geometry_msgs/WrenchStamped.h>\n#include <sensor_msgs/JointState.h>\n#include <tf/transform_broadcaster.h>\n\nnamespace gazebo\n{\n  class ForceTorquePlugin : public ModelPlugin\n  {\n    public: void Load(physics::ModelPtr _parent, sdf::ElementPtr /*_sdf*/)\n    {\n      // Store the model pointer for convenience\n      this->model = _parent;\n\n      // Get the foot link\n      this->footLink = this->model->GetLink("left_foot");\n      if (!this->footLink)\n      {\n        gzerr << "Foot link not found! Make sure the link name is correct." << std::endl;\n        return;\n      }\n\n      // Initialize ROS if not already initialized\n      if (!ros::isInitialized())\n      {\n        int argc = 0;\n        char **argv = NULL;\n        ros::init(argc, argv, "gazebo_ft_sensor",\n                  ros::init_options::NoSigintHandler);\n      }\n\n      // Create ROS node handle\n      this->rosNode.reset(new ros::NodeHandle("gazebo_ft_sensor"));\n\n      // Create publisher for force/torque data\n      this->pub = this->rosNode->advertise<geometry_msgs::WrenchStamped>(\n          "/simple_humanoid/ft_sensor", 100);\n\n      // Listen to the update event (this gets called every simulation iteration)\n      this->updateConnection = event::Events::ConnectWorldUpdateBegin(\n          boost::bind(&ForceTorquePlugin::OnUpdate, this, _1));\n    }\n\n    // Called by the world update start event\n    public: void OnUpdate(const common::UpdateInfo & /*_info*/)\n    {\n      if (this->footLink)\n      {\n        // Get the contact forces on the foot\n        // In a real implementation, this would be more sophisticated\n        // For now, we\'ll simulate basic contact forces\n        ignition::math::Vector3d force = this->footLink->WorldForce();\n        ignition::math::Vector3d torque = this->footLink->WorldTorque();\n\n        // Create and publish ROS message\n        geometry_msgs::WrenchStamped wrench_msg;\n        wrench_msg.header.stamp = ros::Time::now();\n        wrench_msg.header.frame_id = "left_foot";\n\n        wrench_msg.wrench.force.x = force.X();\n        wrench_msg.wrench.force.y = force.Y();\n        wrench_msg.wrench.force.z = force.Z();\n        wrench_msg.wrench.torque.x = torque.X();\n        wrench_msg.wrench.torque.y = torque.Y();\n        wrench_msg.wrench.torque.z = torque.Z();\n\n        this->pub.publish(wrench_msg);\n      }\n    }\n\n    // Pointer to the model\n    private: physics::ModelPtr model;\n\n    // Pointer to the foot link\n    private: physics::LinkPtr footLink;\n\n    // ROS Node and Publisher\n    private: boost::shared_ptr<ros::NodeHandle> rosNode;\n    private: ros::Publisher pub;\n\n    // Connection to the world update event\n    private: event::ConnectionPtr updateConnection;\n  };\n\n  // Register this plugin with the simulator\n  GZ_REGISTER_MODEL_PLUGIN(ForceTorquePlugin)\n}\n'})}),"\n",(0,s.jsxs)(e.ol,{start:"3",children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"Create a CMakeLists.txt for the plugin:"})}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"~/ros2_ws/src/humanoid_simulation/plugins/CMakeLists.txt"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cmake",children:'cmake_minimum_required(VERSION 3.5)\nproject(humanoid_simulation_plugins)\n\n# Default to C++14\nif(NOT CMAKE_CXX_STANDARD)\n  set(CMAKE_CXX_STANDARD 14)\nendif()\n\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")\n  add_compile_options(-Wall -Wextra -Wpedantic)\nendif()\n\n# Find Gazebo\nfind_package(gazebo REQUIRED)\n\n# Find ROS packages\nfind_package(catkin REQUIRED COMPONENTS\n  roscpp\n  std_msgs\n  geometry_msgs\n  sensor_msgs\n  tf\n)\n\n# Set Gazebo CXX flags\nset(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${GAZEBO_CXX_FLAGS}")\n\n# Include directories\ninclude_directories(\n  ${catkin_INCLUDE_DIRS}\n  ${GAZEBO_INCLUDE_DIRS}\n)\n\n# Link directories\nlink_directories(\n  ${GAZEBO_LIBRARY_DIRS}\n)\n\n# Add the plugin library\nadd_library(force_torque_plugin SHARED force_torque_plugin.cpp)\n\n# Link libraries\ntarget_link_libraries(force_torque_plugin\n  ${GAZEBO_LIBRARIES}\n  ${catkin_LIBRARIES}\n)\n\n# Install the plugin\ninstall(TARGETS force_torque_plugin\n  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}\n)\n'})}),"\n",(0,s.jsxs)(e.ol,{start:"4",children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"Update the robot model to use the custom plugin:"})}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Modify the robot model to include the custom plugin:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Add this inside the model tag --\x3e\n<gazebo reference="left_foot">\n  <sensor name="left_foot_ft_sensor" type="force_torque">\n    <always_on>true</always_on>\n    <update_rate>100</update_rate>\n    <plugin name="left_foot_ft_plugin" filename="libforce_torque_plugin.so">\n      <robotNamespace>/simple_humanoid</robotNamespace>\n      <topicName>left_foot/ft_sensor</topicName>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"understanding-the-implementation",children:"Understanding the Implementation"}),"\n",(0,s.jsx)(e.p,{children:"The glass-box view reveals:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"The plugin connects to Gazebo's world update loop to get real-time physics data"}),"\n",(0,s.jsx)(e.li,{children:"It accesses the foot link's forces and torques from the physics engine"}),"\n",(0,s.jsx)(e.li,{children:"It publishes this data as ROS messages for use by control algorithms"}),"\n",(0,s.jsx)(e.li,{children:"The plugin is loaded by Gazebo when the world is loaded and runs alongside the physics simulation"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"tiered-assessments",children:"Tiered Assessments"}),"\n",(0,s.jsx)(e.h3,{id:"tier-1-basic-understanding",children:"Tier 1: Basic Understanding"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"What is the primary physics engine used by Gazebo?"}),"\n",(0,s.jsx)(e.li,{children:"Name three parameters that can be configured for contact physics in Gazebo."}),"\n",(0,s.jsxs)(e.li,{children:["What is the purpose of the ",(0,s.jsx)(e.code,{children:"<world>"})," tag in a Gazebo world file?"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"tier-2-application",children:"Tier 2: Application"}),"\n",(0,s.jsxs)(e.ol,{start:"4",children:["\n",(0,s.jsx)(e.li,{children:"Create a Gazebo world file that includes a humanoid robot and a sloped surface with a 15-degree incline."}),"\n",(0,s.jsx)(e.li,{children:"Implement a simple SDF model for a humanoid robot with at least 6 joints and proper inertial properties."}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"tier-3-analysis-and-synthesis",children:"Tier 3: Analysis and Synthesis"}),"\n",(0,s.jsxs)(e.ol,{start:"6",children:["\n",(0,s.jsx)(e.li,{children:"Design a complete Gazebo simulation environment for testing humanoid robot walking on different terrains (flat, inclined, uneven). Include physics parameters, sensor configurations, and validation metrics to compare simulation vs. real-world performance."}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"mermaid-diagram",children:"Mermaid Diagram"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mermaid",children:"graph TB\n    A[Gazebo Simulator] --\x3e B[Physics Engine]\n    A --\x3e C[Sensor Simulation]\n    A --\x3e D[Rendering Engine]\n\n    B --\x3e E[ODE/Bullet/DART]\n    C --\x3e F[IMU Simulation]\n    C --\x3e G[LiDAR Simulation]\n    C --\x3e H[Camera Simulation]\n    D --\x3e I[OpenGL Rendering]\n\n    J[Humanoid Robot Model] --\x3e K[URDF/SDF]\n    K --\x3e L[Links & Joints]\n    K --\x3e M[Inertial Properties]\n    K --\x3e N[Visual Properties]\n\n    O[ROS 2 Interface] --\x3e P[Message Passing]\n    O --\x3e Q[Service Calls]\n    O --\x3e R[Action Servers]\n\n    E --\x3e J\n    F --\x3e O\n    G --\x3e O\n    H --\x3e O\n    L --\x3e O\n\n    style A fill:#ff9999\n    style J fill:#99ccff\n    style O fill:#99ff99\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Alt-text for diagram:"}),' "Gazebo simulation architecture showing the main Gazebo simulator connected to physics engine, sensor simulation, and rendering engine components. The physics engine connects to ODE/Bullet/DART, sensor simulation connects to IMU, LiDAR, and camera simulation, and rendering engine connects to OpenGL. A humanoid robot model connects through URDF/SDF to define links & joints, inertial properties, and visual properties. A ROS 2 interface connects through message passing, service calls, and action servers. The simulator components are highlighted in pink, robot model in light blue, and ROS interface in light green."']}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"This chapter introduced the fundamentals of Gazebo physics simulation and world building for humanoid robotics. We explored the physics engine capabilities, contact modeling, and sensor simulation that make Gazebo an ideal platform for creating digital twins of humanoid robots. Through practical examples, we demonstrated how to create world files, robot models, and custom plugins that accurately represent real-world physics and sensor behavior."}),"\n",(0,s.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["Koenig, N., & Howard, A. (2004). Design and use paradigms for Gazebo, an open-source multi-robot simulator. ",(0,s.jsx)(e.em,{children:"Proceedings of the 2004 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)"}),", 2149-2154."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Tedrake, R. (2019). Underactuated robotics: Algorithms for walking, running, swimming, flying, and manipulation. MIT Press."}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Siciliano, B., & Khatib, O. (2016). Springer handbook of robotics. Springer Publishing Company, Incorporated."}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["Coumans, E., & Bai, Y. (2016). Mujoco: A physics engine for model-based control. ",(0,s.jsx)(e.em,{children:"IEEE International Conference on Simulation, Modeling, and Programming for Autonomous Robots (SIMPAR)"}),", 1-6."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Featherstone, R. (2008). Rigid body dynamics algorithms. Springer Science & Business Media."}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["Kanehiro, F., Hirukawa, H., & Akachi, K. (2014). Open humanoids platform to accelerate the development of humanoid technology. ",(0,s.jsx)(e.em,{children:"Humanoid Robots (Humanoids), 2014 14th IEEE-RAS International Conference on"}),", 909-916."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["Collet, J., Maignan, A., & Pustowka, F. (2021). Real-time performance of ROS 2 for robotic control applications. ",(0,s.jsx)(e.em,{children:"IEEE Transactions on Robotics"}),", 37(4), 1201-1215."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["Ha, I., Tamura, Y., Asama, H., &\u767d\u4e91, J. (2015). Real-time walking pattern generation based on control of the zero-moment point for a full-size humanoid robot. ",(0,s.jsx)(e.em,{children:"Advanced Robotics"}),", 29(1), 1-14."]}),"\n"]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>r});var o=i(6540);const s={},a=o.createContext(s);function t(n){const e=o.useContext(a);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:t(n.components),o.createElement(a.Provider,{value:e},n.children)}}}]);